/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/**
 * The main build script for JavaFX.
 *
 * MUST FIX tasks to complete:
 *  - build check -- making sure the final artifact has the right bits
 *      - some things worth automatically sanity checking:
 *          - are there images in the javadocs?
 *          - are all of the expected dylibs etc there?
 *          - is jfxrt.jar there?
 *          - does jfxrt.jar contain stuff it shouldn't (doc-files, iml, etc)
 *          - does jfxrt.jar contain stuff it should (bss files, etc)
 *  - Perform sanity checking to make sure a JDK exists with javac, javah, etc
 *  - Support building with no known JDK location, as long as javac, javah, etc are on the path
 *  - Check all of the native flags. We're adding weight to some libs that don't need it, and so forth.
 *
 * Additional projects to work on as we go:
 *  - Add "developer debug". This is where the natives do not have debug symbols, but the Java code does
 *  - The genVSproperties.bat doesn't find the directory where RC.exe lives. So it is hard coded. Might be a problem.
 *  - special tasks for common needs, such as:
 *      - updating copyright headers
 *      - stripping trailing whitespace (?)
 *  - checkstyle
 *  - findbugs
 *  - re needs?
 *  - sqe testing
 *  - API change check
 *  - Pushing results to a repo?
 *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.
 *  - Integrate Parfait reports for C code
 *  - FXML Project tests are not running
 */
defaultTasks = ["sdk"]

import java.util.concurrent.CountDownLatch
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.Future

/******************************************************************************
 *                              Utility methods                               *
 *****************************************************************************/

/**
 * If the given named property is not defined, then this method will define
 * it with the given defaultValue. Any properties defined by this method can
 * be substituted on the command line by using -P, or by specifying a
 * gradle.properties file in the user home dir
 *
 * @param name The name of the property to define
 * @param defaultValue The default value to assign the property
 */
void defineProperty(String name, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, defaultValue);
    }
}

/**
 * If the given named property is not defined, then this method will attempt to
 * look up the property in the props map, and use the defaultValue if it cannot be found.
 *
 * @param name The name of the property to look up and/or define
 * @param props The properties to look for the named property in, if it has not already been defined
 * @param defaultValue The default value if the property has not been defined and the
 *                     props map does not contain the named property
 */
void defineProperty(String name, Properties props, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, props.getProperty(name, defaultValue));
    }
}

/**
 * Converts cygwin style paths to windows style paths, but with a forward slash.
 * This method is safe to call from any platform, and will only do work if
 * called on Windows (in all other cases it simply returns the supplied path.
 * In the future I would like to modify this so that it only does work if
 * cygwin is installed, as I hope one day to remove the requirement to build
 * with cygwin, but at present (due to GStreamer / Webkit) cygwin is needed
 * anyway.
 *
 * @param path the path to convert
 * @return the path converted to windows style, if on windows, otherwise it
 *         is the supplied path.
 */
String cygpath(String path) {
    if (!IS_WINDOWS) return path;
    if (path == null || "".equals(path)) return path;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    logger.info("Converting path '$path' via cygpath")
    exec {
        standardOutput = out
        commandLine "cmd", "/c", "cygpath", "-m", path
    }
    return out.toString().trim();
}

void loadProperties(String sourceFileName) {
    def config = new Properties()
    def propFile = new File(sourceFileName)
    if (propFile.canRead()) {
        config.load(new FileInputStream(propFile))
        for (java.util.Map.Entry property in config) {
            def keySplit = property.key.split("\\.");
            def key = keySplit[0];
            for (int i = 1; i < keySplit.length; i++) {
                key = key + keySplit[i].capitalize();
            }
            ext[key] = property.value;
        }
    }
}

/**
 * Struct used to contain some information passed to the closure
 * passed to compileTargets.
 */
class CompileTarget {
    String name;
    String upper;
    String capital;
}

/**
 * Iterates over each of the compile targets, passing the given closure
 * a CompileTarget instance.
 *
 * @param c The closure to call
 */
void compileTargets(Closure c) {
    if (COMPILE_TARGETS == "") {
        return
    }
    COMPILE_TARGETS.split(",").each { target ->
        CompileTarget ct = new CompileTarget();
        ct.name = target;
        ct.upper = target.trim().toUpperCase(Locale.ROOT)
        ct.capital = target.trim().capitalize()
        c(ct)
    }
}

/**
 * Manages the execution of some closure which is responsible for producing
 * content for a properties file built at build time and stored in the
 * root project's $buildDir, and then loading that properties file and
 * passing it to the processor closure.
 *
 * This is used on windows to produce a properties file containing all the
 * windows visual studio paths and environment variables, and on Linux
 * for storing the results of pkg-config calls.
 *
 * @param name the name of the file to produce
 * @param loader a closure which is invoked, given the properties file. This
 *        closure is invoked only if the properties file needs to be created
 *        and is responsible for populating the properties file.
 * @param processor a closure which is invoked every time this method is
 *        called and which will be given a Properties object, fully populated.
 *        The processor is then responsible for doing whatever it is that it
 *        must do with those properties (such as setting up environment
 *        variables used in subsequent native builds, or whatnot).
 */
void setupTools(String name, Closure loader, Closure processor) {
    // Check to see whether $buildDir/$name.properties file exists. If not,
    // then generate it. Once generated, we need to read the properties file to
    // help us define the defaults for this block of properties
    File propFile = file("$buildDir/${name}.properties");
    if (!propFile.exists()) {
        // Create the properties file
        propFile.getParentFile().mkdirs();
        propFile.createNewFile();
        loader(propFile);
    }

    // Try reading the properties in order to define the properties. If the property file cannot
    // be located, then we will throw an exception because we cannot guess these values
    InputStream propStream = null;
    try {
        Properties properties = new Properties();
        propStream = new FileInputStream(propFile);
        properties.load(propStream);
        processor(properties);
    } finally {
        try { propStream.close() } catch (Exception e) { }
    }
}

String[] parseJavaVersion(String jRuntimeVersion) {
    def jVersion = jRuntimeVersion.split("[-\\+]")[0]
    def tmpBuildNumber = "0"
    if (jVersion.startsWith("1.")) {
        // This is a pre-JEP-223 version string
        def dashbIdx = jRuntimeVersion.lastIndexOf("-b")
        if (dashbIdx != -1) {
            tmpBuildNumber = jRuntimeVersion.substring(dashbIdx + 2)
        }
    } else {
        // This is a post-JEP-223 version string
        def plusIdx = jRuntimeVersion.indexOf("+")
        if (plusIdx != -1) {
            tmpBuildNumber = jRuntimeVersion.substring(plusIdx + 1)
        }
    }
    def jBuildNumber = tmpBuildNumber.split("[-\\+]")[0]
    def versionInfo = new String[2];
    versionInfo[0] = jVersion
    versionInfo[1] = jBuildNumber
    return versionInfo
}

/**
 * Fails the build with the specified error message
 *
 * @param msg the reason for the failure
 */
void fail(String msg) {
    throw new GradleException("FAIL: " + msg);
}

/******************************************************************************
 *                                                                            *
 *                   Definition of project properties                         *
 *                                                                            *
 *  All properties defined using ext. are immediately available throughout    *
 *  the script as variables that can be used. These variables are attached    *
 *  to the root project (whereas if they were defined as def variables then   *
 *  they would only be available within the root project scope).              *
 *                                                                            *
 *  All properties defined using the "defineProperty" method can be replaced  *
 *  on the command line by using the -P flag. For example, to override the    *
 *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *
 *                                                                            *
 *****************************************************************************/

// If the ../rt-closed directory exists, then we are doing a closed build.
// In this case, build and property files will be read from
// ../rt-closed/closed-build.gradle and ../rt-closed/closed-properties.gradle
// respectively

def closedDir = file("../rt-closed")
def buildClosed = closedDir.isDirectory()
ext.BUILD_CLOSED = buildClosed

// These variables indicate what platform is running the build. Is
// this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?
ext.OS_NAME = System.getProperty("os.name").toLowerCase()
ext.OS_ARCH = System.getProperty("os.arch")
ext.IS_64 = OS_ARCH.toLowerCase().contains("64")
ext.IS_MAC = OS_NAME.contains("mac") || OS_NAME.contains("darwin")
ext.IS_WINDOWS = OS_NAME.contains("windows")
ext.IS_LINUX = OS_NAME.contains("linux")

// Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,
// use a user supplied JDK_HOME, STUB_RUNTIME, JAVAC, and/or JAVAH, all of which may be specified
// independently (or we'll try to get the right one based on other supplied info). Sometimes the
// JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:
//    c:\Program Files (x86)\Java\jdk1.8.0\jre
//    c:\Program Files (x86)\Java\jre8\
// Because of this, you may sometimes get the jdk's JRE (in which case the logic we used to have here
// was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).
def envJavaHome = cygpath(System.getenv("JDK_HOME"))
if (envJavaHome == null || envJavaHome.equals("")) envJavaHome = cygpath(System.getenv("JAVA_HOME"))
def javaHome = envJavaHome == null || envJavaHome.equals("") ? System.getProperty("java.home") : envJavaHome
def javaHomeFile = file(javaHome)
defineProperty("JDK_HOME",
        javaHomeFile.name == "jre" ?
        javaHomeFile.getParent().toString() :
        javaHomeFile.name.startsWith("jre") ?
        new File(javaHomeFile.getParent(), "jdk1.${javaHomeFile.name.substring(3)}.0").toString() :
        javaHome) // we have to bail and set it to something and this is as good as any!
ext.JAVA_HOME = JDK_HOME

// Check whether JIGSAW_HOME is set. If it is, then it points to a JDK9
// jigsaw build with modularization enabled and can be used for testing
def envJigsawHome = cygpath(System.getenv("JIGSAW_HOME"))
defineProperty("JIGSAW_HOME", envJigsawHome);

if (JIGSAW_HOME == null || JIGSAW_HOME == "") {
    logger.warn("JIGSAW_HOME is not set");
    ext.USE_JIGSAW = false
} else {
    ext.USE_JIGSAW = true
}

defineProperty("JAVA", cygpath("$JDK_HOME/bin/java${IS_WINDOWS ? '.exe' : ''}"))
defineProperty("JIGSAW_JAVA", cygpath("$JIGSAW_HOME/bin/java${IS_WINDOWS ? '.exe' : ''}"))
defineProperty("JAVAC", cygpath("$JDK_HOME/bin/javac${IS_WINDOWS ? '.exe' : ''}"))
defineProperty("JIGSAW_JAVAC", cygpath("$JIGSAW_HOME/bin/javac${IS_WINDOWS ? '.exe' : ''}"))
defineProperty("JAVAH", cygpath("$JDK_HOME/bin/javah${IS_WINDOWS ? '.exe' : ''}"))
defineProperty("JAVADOC", cygpath("$JDK_HOME/bin/javadoc${IS_WINDOWS ? '.exe' : ''}"))
defineProperty("JDK_DOCS", "https://docs.oracle.com/javase/8/docs/api/")
defineProperty("JIGSAW_MODULES", cygpath(System.getenv("JIGSAW_MODULES")) ?: "")

defineProperty("javaRuntimeVersion", System.getProperty("java.runtime.version"))
def javaVersionInfo = parseJavaVersion(javaRuntimeVersion)
defineProperty("javaVersion", javaVersionInfo[0])
defineProperty("javaBuildNumber", javaVersionInfo[1])

loadProperties("$projectDir/build.properties")

// Look for stub runtime in either old (JDK 8u) or new (JDK 9) dir layout

def cachesSdkRtDir = file("../caches/sdk/rt")
def hasRtDir = cachesSdkRtDir.isDirectory()
def String closedCacheStubRuntime = cygpath("$projectDir") + "/../caches/sdk" + (hasRtDir ? "/rt" : "")

def jdkHomeJreDir = file("$JDK_HOME/jre")
def hasJreDir = jdkHomeJreDir.isDirectory()
def String jreStubRuntime = cygpath("$JDK_HOME") + (hasJreDir ? "/jre" : "")

defineProperty("STUB_RUNTIME", BUILD_CLOSED ? closedCacheStubRuntime : jreStubRuntime)

defineProperty("LIBRARY_STUB", IS_MAC ? "$STUB_RUNTIME/lib" :
                               IS_WINDOWS ? "$STUB_RUNTIME/bin" :
                               "$STUB_RUNTIME/lib/$OS_ARCH")
defineProperty("UPDATE_STUB_CACHE", (STUB_RUNTIME.equals(closedCacheStubRuntime) ? 'true' : 'false'))

def supplementalPreBuildFile = file("$closedDir/closed-pre-build.gradle");
def supplementalBuildFile = file("$closedDir/closed-build.gradle");

if (BUILD_CLOSED) {
    apply from: supplementalPreBuildFile
}

// GRADLE_VERSION_CHECK specifies whether to fail the build if the
// gradle version check fails
defineProperty("GRADLE_VERSION_CHECK", "true")
ext.IS_GRADLE_VERSION_CHECK = Boolean.parseBoolean(GRADLE_VERSION_CHECK)

// COMPILE_WEBKIT specifies whether to build all of webkit.
defineProperty("COMPILE_WEBKIT", "false")
ext.IS_COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)

// COMPILE_MEDIA specifies whether to build all of media.
defineProperty("COMPILE_MEDIA", "false")
ext.IS_COMPILE_MEDIA = Boolean.parseBoolean(COMPILE_MEDIA)

// COMPILE_PANGO specifies whether to build javafx_font_pango.
defineProperty("COMPILE_PANGO", "${IS_LINUX}")
ext.IS_COMPILE_PANGO = Boolean.parseBoolean(COMPILE_PANGO)

// COMPILE_HARFBUZZ specifies whether to use Harfbuzz.
defineProperty("COMPILE_HARFBUZZ", "false")
ext.IS_COMPILE_HARFBUZZ = Boolean.parseBoolean(COMPILE_HARFBUZZ)

// COMPILE_PARFAIT specifies whether to build parfait
defineProperty("COMPILE_PARFAIT", "false")
ext.IS_COMPILE_PARFAIT = Boolean.parseBoolean(COMPILE_PARFAIT)

// FIXME: update the default when using 9 (pre-jigsaw) as boot jdk
// COMPILE_JFR specifies whether to build code that logs to JRockit Flight Recorder
defineProperty("COMPILE_JFR", Boolean.toString(file("$JDK_HOME/jre/lib/jfr.jar").exists()))
ext.IS_COMPILE_JFR = Boolean.parseBoolean(COMPILE_JFR)

// BUILD_FXPACKAGER enables building the packager modules and native code
defineProperty("BUILD_FXPACKAGER", "false")
ext.IS_BUILD_FXPACKAGER = Boolean.parseBoolean(BUILD_FXPACKAGER)

// RETAIN_PACKAGER_TESTS specifies whether the tests in fxpackager should
// keep generated files instead of attempting to automatically delete them
defineProperty("RETAIN_PACKAGER_TESTS", "false")
ext.IS_RETAIN_PACKAGER_TESTS = Boolean.parseBoolean(RETAIN_PACKAGER_TESTS)

// TEST_PACKAGER_DMG whether tests that create DMG files via hdiutil
// should be run.  On OSX 10.7 this tends to hang automated builds
defineProperty("TEST_PACKAGER_DMG", "false")
ext.IS_TEST_PACKAGER_DMG = Boolean.parseBoolean(TEST_PACKAGER_DMG)

// Define the SWT.jar that we are going to have to download during the build process based
// on what platform we are compiling from (not based on our target).
ext.SWT_FILE_NAME = IS_MAC ? "org.eclipse.swt.cocoa.macosx.x86_64_3.7.2.v3740f" :
    IS_WINDOWS && IS_64 ? "org.eclipse.swt.win32.win32.x86_64_3.7.2.v3740f" :
    IS_WINDOWS && !IS_64 ? "org.eclipse.swt.win32.win32.x86_3.7.2.v3740f" :
    IS_LINUX && IS_64 ? "org.eclipse.swt.gtk.linux.x86_64_3.7.2.v3740f" :
    IS_LINUX && !IS_64 ? "org.eclipse.swt.gtk.linux.x86_3.7.2.v3740f" : ""

// Build javadocs only if BUILD_JAVADOC=true
defineProperty("BUILD_JAVADOC", "false")
ext.IS_BUILD_JAVADOC = Boolean.parseBoolean(BUILD_JAVADOC)

// Specifies whether to build the javafx-src bundle
defineProperty("BUILD_SRC_ZIP", "false")
ext.IS_BUILD_SRC_ZIP = Boolean.parseBoolean(BUILD_SRC_ZIP)

// Specifies whether to run full tests (true) or smoke tests (false)
defineProperty("FULL_TEST", "false")
ext.IS_FULL_TEST = Boolean.parseBoolean(FULL_TEST);

defineProperty("JIGSAW_TEST", "true")
ext.IS_JIGSAW_TEST = Boolean.parseBoolean(JIGSAW_TEST) && USE_JIGSAW

defineProperty("FORCE_TESTS", "false")
ext.IS_FORCE_TESTS = Boolean.parseBoolean(FORCE_TESTS);

// Specifies whether to run robot-based visual tests (only used when FULL_TEST is also enabled)
defineProperty("USE_ROBOT", "false")
ext.IS_USE_ROBOT = Boolean.parseBoolean(USE_ROBOT);

// Specified whether to run tests in headless mode
defineProperty("HEADLESS_TEST", "false")
ext.IS_HEADLESS_TEST = Boolean.parseBoolean(HEADLESS_TEST);

// Specifies whether to run system tests that depend on AWT (only used when FULL_TEST is also enabled)
defineProperty("AWT_TEST", "true")
ext.IS_AWT_TEST = Boolean.parseBoolean(AWT_TEST);

// Specifies whether to run unstable tests (true) - tests that don't run well with Hudson builds
// These tests should be protected with :
//    assumeTrue(Boolean.getBoolean("unstable.test"));
defineProperty("UNSTABLE_TEST", "false")
ext.IS_UNSTABLE_TEST = Boolean.parseBoolean(UNSTABLE_TEST);

// Specify the build configuration (Release, Debug, or DebugNative)
defineProperty("CONF", "Debug")
ext.IS_DEBUG_JAVA = CONF == "Debug" || CONF == "DebugNative"
ext.IS_DEBUG_NATIVE = CONF == "DebugNative"

// Defines the compiler warning levels to use. If empty, then no warnings are generated. If
// not empty, then the expected syntax is as a space or comma separated list of names, such
// as defined in the javac documentation.
defineProperty("LINT", "none")
ext.IS_LINT = LINT != "none"

defineProperty("DOC_LINT", "none")
ext.IS_DOC_LINT = DOC_LINT != "none"

// Specifies whether to use the "useDepend" option when compiling Java sources
defineProperty("USE_DEPEND", "true")
ext.IS_USE_DEPEND = Boolean.parseBoolean(USE_DEPEND)

// Specifies whether to use the "incremental" option when compiling Java sources
defineProperty("INCREMENTAL", "false")
ext.IS_INCREMENTAL = Boolean.parseBoolean(INCREMENTAL)

// Specifies whether to include the Null3D pipeline (for perf debugging)
defineProperty("INCLUDE_NULL3D", "false")
ext.IS_INCLUDE_NULL3D = Boolean.parseBoolean(INCLUDE_NULL3D)

// Specifies whether to include the ES2 pipeline if available
defineProperty("INCLUDE_ES2", IS_WINDOWS ? "false" : "true")
ext.IS_INCLUDE_ES2 = Boolean.parseBoolean(INCLUDE_ES2)

// Specifies whether to generate code coverage statistics when running tests
defineProperty("JCOV", "false")
ext.DO_JCOV = Boolean.parseBoolean(JCOV)

// Define the number of threads to use when compiling (specifically for native compilation)
// On Mac we limit it to 1 by default due to problems running gcc in parallel
if (IS_MAC) {
    defineProperty("NUM_COMPILE_THREADS", "1")
} else {
    defineProperty("NUM_COMPILE_THREADS", "${Runtime.runtime.availableProcessors()}")
}

//
// The next three sections of properties are used to generate the
// VersionInfo class, and the Windows DLL manifest.
//

// The following properties should be left alone by developers and set only from Hudson.
defineProperty("HUDSON_JOB_NAME", "not_hudson")
defineProperty("HUDSON_BUILD_NUMBER","0000")
defineProperty("PROMOTED_BUILD_NUMBER", "0")

// The following properties define the product name for Oracle JDK and OpenJDK
// for VersionInfo and the DLL manifest.
if (BUILD_CLOSED) {
    defineProperty("PRODUCT_NAME", "Java(TM)")
    defineProperty("COMPANY_NAME", "Oracle Corporation")
    defineProperty("PLATFORM_NAME", "Platform SE")
} else {
    defineProperty("PRODUCT_NAME", "OpenJFX")
    defineProperty("COMPANY_NAME", "N/A")
    defineProperty("PLATFORM_NAME", "Platform")
}

// The following properties are set based on properties defined in
// build.properties. The release version and suffix should be updated
// in that file.
def relVer = 0
if (jfxReleasePatchVersion == "0") {
    if (jfxReleaseSecurityVersion == "0") {
        if (jfxReleaseMinorVersion == "0") {
            relVer = "${jfxReleaseMajorVersion}"
        } else {
            relVer = "${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}"
        }
    } else {
        relVer = "${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}"
    }
} else {
    relVer = "${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}"
}
defineProperty("RELEASE_VERSION", relVer)
defineProperty("RELEASE_VERSION_PADDED", "${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}")

def buildDate = new java.util.Date()
def buildTimestamp = new java.text.SimpleDateFormat("yyyy-MM-dd-HHmmss").format(buildDate)
defineProperty("BUILD_TIMESTAMP", buildTimestamp)
def relSuffix = ""
def relOpt = ""
if (HUDSON_JOB_NAME == "not_hudson") {
    relSuffix = "-internal"
    relOpt = "-${buildTimestamp}"
} else {
    relSuffix = jfxReleaseSuffix
}
defineProperty("RELEASE_SUFFIX", relSuffix)
defineProperty("RELEASE_VERSION_SHORT", "${RELEASE_VERSION}${RELEASE_SUFFIX}")
defineProperty("RELEASE_VERSION_LONG", "${RELEASE_VERSION_SHORT}+${PROMOTED_BUILD_NUMBER}${relOpt}")

// Check whether the COMPILE_TARGETS property has been specified (if so, it was done by
// the user and not by this script). If it has not been defined then default
// to building the normal desktop build for this machine
project.ext.set("defaultHostTarget", IS_MAC ? "mac" : IS_WINDOWS ? "win" : IS_LINUX ? "linux" : "");
defineProperty("COMPILE_TARGETS", "$defaultHostTarget")

// Flag indicating whether to import cross compile tools
def importCrossTools = BUILD_CLOSED ? true : false;
if (!importCrossTools && hasProperty("IMPORT_CROSS_TOOLS")) {
    importCrossTools = Boolean.parseBoolean(IMPORT_CROSS_TOOLS);
}
ext.IS_IMPORT_CROSS_TOOLS = importCrossTools

// Location of the cross compile tools
def crossToolsDir = "../crosslibs"
if (hasProperty("CROSS_TOOLS_DIR")) {
    crossToolsDir = CROSS_TOOLS_DIR
}
ext.CROSS_TOOLS_DIR = file(crossToolsDir)

// Specifies whether to run tests with the present jfxrt.jar instead of compiling the new one
defineProperty("BUILD_SDK_FOR_TEST", "true")
ext.DO_BUILD_SDK_FOR_TEST = Boolean.parseBoolean(BUILD_SDK_FOR_TEST)

// Specifies the location to point at SDK build when DO_BUILD_SDK_FOR_TEST set to false
// Used to get location of jfxrt.jar, ant-javafx.jar and javafx-mx.jar
defineProperty("TEST_SDK", JDK_HOME)
ext.TEST_SDK_DIR = file(TEST_SDK)

def rtDir = TEST_SDK_DIR
ext.jfxrtJarFromSdk = new File(rtDir, "lib/jfxrt.jar").absolutePath
if (!DO_BUILD_SDK_FOR_TEST && !file(jfxrtJarFromSdk).exists()) {
    fail ("BUILD_SDK_FOR_TEST is set to false, but there\'s no jfxrt.jar at the expected paths in TEST_SDK($TEST_SDK_DIR)\n"
            + "TEST_SDK should point at either JavaFX SDK location or JDK location\n"
            + "Please, set the correct TEST_SDK")
}

// These tasks would be disabled when running with DO_BUILD_SDK_FOR_TEST=false as they're unneeded for running tests
def disabledTasks = DO_BUILD_SDK_FOR_TEST ? [] : ["compileJava", "processResources", "classes", // all projects
         "generateDecoraShaders", "generatePrismShaders",
         "compilePrismCompilers", "compilePrismJavaShaders", "compileDecoraCompilers", // :graphics
         "processDecoraShaders", "processPrismShaders"]

/**
 * Fetch/Check that external tools are present for the build. This method
 * will conditionally download the packages from project defined ivy repositories
 * and unpack them into the specified destdir
 *
 * @param configName A unique name to distinguish the configuration (ie "ARMSFV6")
 * @param packages A list of required packages (with extensions .tgz, .zip)
 * @param destdir where the packages should be unpacked
 * @param doFetch if true, the named packages will be download
 */
void fetchExternalTools(String configName, List packages, File destdir, boolean doFetch) {
    if (doFetch) {
        // create a unique configuration for this fetch
        def String fetchToolsConfig = "fetchTools$configName"
        rootProject.configurations.create(fetchToolsConfig)

        def List<String> fetchedPackages = []
        def int fetchCount = 0

        packages.each { pkgname->
            def int dotdex = pkgname.lastIndexOf('.')
            def int dashdex = pkgname.lastIndexOf('-')
            def String basename = pkgname.substring(0,dashdex)
            def String ver = pkgname.substring(dashdex+1,dotdex)
            def String ext = pkgname.substring(dotdex+1)
            def File pkgdir = file("$destdir/$basename-$ver")

            if (!pkgdir.isDirectory()) {
                rootProject.dependencies.add(fetchToolsConfig, "javafx:$basename:$ver", {
                    artifact {
                        name = basename
                        version = ver
                        type = ext
                    }
                })
                println "adding $pkgname as a downloadable item did not find $pkgdir"
                fetchedPackages.add(pkgname)
                fetchCount++
            }
        }

        //fetch all the missing packages
        if (fetchedPackages.size > 0) {
            destdir.mkdirs()

            logger.quiet "fetching missing packages $fetchedPackages"
            copy {
                from rootProject.configurations[fetchToolsConfig]
                into destdir
            }

            // unpack the fetched packages
            fetchedPackages.each { pkgname->
                logger.quiet "expanding the package $pkgname"
                def srcball = file("${destdir}/${pkgname}")

                if (!srcball.exists()) {
                    throw new GradleException("Failed to fetch $pkgname");
                }

                def String basename = pkgname.substring(0,pkgname.lastIndexOf("."))
                def File pkgdir = file("$destdir/$basename")

                if (pkgname.endsWith(".tgz")) {
                    if (IS_LINUX || IS_MAC) {
                        // use native tar to support symlinks
                        pkgdir.mkdirs()
                        exec {
                            workingDir pkgdir
                            commandLine "tar", "zxf", "${srcball}"
                         }
                    } else {
                        copy {
                            from tarTree(resources.gzip("${srcball}"))
                            into pkgdir
                        }
                    }
                } else if (pkgname.endsWith(".zip")) {
                     copy {
                         from zipTree("${srcball}")
                         into pkgdir
                     }
                } else {
                    throw new GradleException("Unhandled package type for compile package ${pkgname}")
                }
                srcball.deleteOnExit();
            }
        } else {
            logger.quiet "all tool packages are present $packages"
        }
    } else { // !doFetch - so just check they are present
        // check that all the dirs are really there
        def List<String> errors = []
        packages.each { pkgname->
            def String basename = pkgname.substring(0,pkgname.lastIndexOf("."))
            def File pkgdir = file("$destdir/$basename")

            if (!pkgdir.isDirectory()) {
                errors.add(pkgname)
            }
        }
        if (errors.size > 0) {
            throw new GradleException("Error: missing tool packages: $errors")
        } else {
            logger.quiet "all tool packages are present $packages"
        }
    }
}

// Now we need to define the native compilation tasks. The set of parameters to
// native compilation depends on the target platform (and also to some extent what platform
// you are compiling on). These settings are contained in various gradle files
// such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer
// can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file
// that will contain the appropriate flags.
defineProperty("COMPILE_FLAGS_FILES", COMPILE_TARGETS.split(",").collect {"buildSrc/${it.trim()}.gradle"}.join(","))
if (COMPILE_TARGETS == "all") {
    def tmp = []
    File buildSrcDir = file("buildSrc")
    buildSrcDir.listFiles().each { File f ->
        if (f.isFile() && f.name.endsWith(".gradle") && !f.name.equals("build.gradle")) {
            def target = f.name.substring(0, f.name.lastIndexOf('.gradle')).toUpperCase(Locale.ROOT)
            apply from: f
            if (project.ext["${target}"].canBuild) {
                tmp.add(target)
            }
        }
    }
    COMPILE_FLAGS_FILES = tmp.collect { "buildSrc/${it}.gradle"}.join(",")
    COMPILE_TARGETS = tmp.collect { "${it.toLowerCase()}"}.join(",")
} else {
    COMPILE_FLAGS_FILES.split(",").each {
        logger.info("Applying COMPILE_FLAGS_FILE '$it'")
        apply from: it
    }
}

if (COMPILE_TARGETS != "") {
    def tmp = []
    COMPILE_TARGETS.split(",").each {target ->
        if (project.ext["${target.toUpperCase(Locale.ROOT)}"].canBuild) {
            tmp.add(target)
        }
    }
    COMPILE_TARGETS = tmp.collect { "${it.toLowerCase()}"}.join(",")
}

// Sanity check the expected properties all exist
compileTargets { t ->
    // Every platform must define these variables
    if (!project.hasProperty(t.upper)) throw new Exception("ERROR: Incorrectly configured compile flags file, missing ${t.name} property")
    def props = project.ext[t.upper];
    ["compileSwing", "compileSWT", "compileFXPackager", "libDest"].each { prop ->
        if (!props.containsKey(prop)) throw new Exception("ERROR: Incorrectly configured compile flags file, missing ${prop} property on ${t.name}")
    }
}

// Various build flags may be set by the different target files, such as
// whether to build Swing, SWT, FXPackager, etc. We iterate over all
// compile targets and look for these settings in our properties. Note that
// these properties cannot be set from the command line, but are set by
// the target build files such as armv6hf.gradle or mac.gradle.
ext.COMPILE_SWING = false;
ext.COMPILE_SWT = false;
ext.COMPILE_FXPACKAGER = false;
compileTargets { t ->
    def targetProperties = project.rootProject.ext[t.upper]

    if (targetProperties.compileSwing) COMPILE_SWING = true
    if (targetProperties.compileSWT) COMPILE_SWT = true
    if (IS_BUILD_FXPACKAGER && JIGSAW_HOME && targetProperties.compileFXPackager) COMPILE_FXPACKAGER = true

    if (!targetProperties.containsKey('compileWebnodeNative')) {
        // unless specified otherwise, we will compile native Webnode if IS_COMPILE_WEBKIT
        targetProperties.compileWebnodeNative = true
    }

    if (!targetProperties.containsKey('compileMediaNative')) {
        // unless specified otherwise, we will compile native Media if IS_COMPILE_MEDIA
        targetProperties.compileMediaNative = true
    }

    if (!targetProperties.containsKey('includeSWT')) targetProperties.includeSWT = true
    if (!targetProperties.containsKey('includeSwing')) targetProperties.includeSwing = true
    if (!targetProperties.containsKey('includeNull3d')) targetProperties.includeNull3d = true
    if (!targetProperties.containsKey('includeLens')) targetProperties.includeLens = false
    if (!targetProperties.containsKey('includeMonocle')) targetProperties.includeMonocle = false
    if (!targetProperties.containsKey('includeEGL')) targetProperties.includeEGL = false

    if (!targetProperties.containsKey('includeGTK')) targetProperties.includeGTK = IS_LINUX

    // This value is used as a prefix for various directories under ./build,
    // such as sdk, to allow for a common name for the hosted build
    // (for use when building apps) and a unique name for cross builds.
    if (rootProject.defaultHostTarget.equals(t.name)) {
        // use a simple common default for the "host" build
        targetProperties.platformPrefix=""
    } else {
        // and a more complex one for cross builds
        targetProperties.platformPrefix="${t.name}-"
    }
}

/******************************************************************************
 *                                                                            *
 *                         Build Setup Sanity Checks                          *
 *                                                                            *
 *  Here we do a variety of checks so that if the version of Java you are     *
 *  building with is misconfigured, or you are using the wrong version of     *
 *  gradle, etc you will get some kind of helpful error / warning message     *
 *                                                                            *
 *****************************************************************************/

// Verify that the architecture & OS are supported configurations. Note that
// at present building on PI is not supported, but we would only need to make
// some changes on assumptions on what should be built (like SWT / Swing) and
// such and we could probably make it work.
if (!IS_MAC && !IS_WINDOWS && !IS_LINUX) logger.error("Unsupported build OS ${OS_NAME}")
if (IS_WINDOWS && OS_ARCH != "x86" && OS_ARCH != "amd64") {
    throw new Exception("Unknown and unsupported build architecture: $OS_ARCH")
} else if (IS_MAC && OS_ARCH != "x86_64") {
    throw new Exception("Unknown and unsupported build architecture: $OS_ARCH")
} else if (IS_LINUX && OS_ARCH != "i386" && OS_ARCH != "amd64") {
    throw new Exception("Unknown and unsupported build architecture: $OS_ARCH")
}

// Sanity check that we actually have a list of compile targets to execute
if (COMPILE_TARGETS == null || COMPILE_TARGETS == "") {
    throw new Exception("Unable to determine compilation platform, must specify valid COMPILE_TARGETS!")
}

// Make sure JDK_HOME/bin/java exists
if (!file(JAVA).exists()) throw new Exception("Missing or incorrect path to 'java': '$JAVA'. Perhaps bad JDK_HOME? $JDK_HOME")
if (!file(JIGSAW_JAVA).exists()) logger.warn("Missing or incorrect path to JIGSAW 'java': '$JIGSAW_JAVA'. Perhaps bad JIGSAW_HOME? $JIGSAW_HOME")
if (!file(JAVAC).exists()) throw new Exception("Missing or incorrect path to 'javac': '$JAVAC'. Perhaps bad JDK_HOME? $JDK_HOME")
if (!file(JIGSAW_JAVAC).exists()) logger.warn("Missing or incorrect path to JIGSAW 'javac': '$JIGSAW_JAVAC'. Perhaps bad JIGSAW_HOME? $JIGSAW_HOME")
if (!file(JAVAH).exists()) throw new Exception("Missing or incorrect path to 'javah': '$JAVAH'. Perhaps bad JDK_HOME? $JDK_HOME")
if (!file(JAVADOC).exists()) throw new Exception("Missing or incorrect path to 'javadoc': '$JAVADOC'. Perhaps bad JDK_HOME? $JDK_HOME")

// Determine the verion of Java in JDK_HOME. It looks like this:
//
// $ java -version
// java version "1.7.0_45"
// Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
// Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
//
// We need to parse the second line
def inStream = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, "-fullversion").start().getErrorStream()));
try {
    String v = inStream.readLine().trim();
    if (v != null) {
        int ib = v.indexOf("full version \"");
        if (ib != -1) {
            String str = v.substring(ib);
            String ver = str.substring(str.indexOf("\"") + 1, str.size() - 1);

            defineProperty("jdkRuntimeVersion", ver)
            def jdkVersionInfo = parseJavaVersion(ver)
            defineProperty("jdkVersion", jdkVersionInfo[0])
            defineProperty("jdkBuildNumber", jdkVersionInfo[1])
        }
    }
} finally {
    inStream.close();
}
if (!project.hasProperty("jdkRuntimeVersion")) throw new Exception("Unable to determine the version of Java in JDK_HOME at $JDK_HOME");



// Verify that CONF is something useful
if (CONF != "Release" && CONF != "Debug" && CONF != "DebugNative") {
    logger.warn("Unknown configuration CONF='$CONF'. Treating as 'Release'")
}

// If the number of compile threads is less than 1 then we have a problem!
if (Integer.parseInt(NUM_COMPILE_THREADS.toString()) < 1) {
    logger.warn("NUM_COMPILE_THREADS was specified as '$NUM_COMPILE_THREADS' which is less than the minimum value of 1. " +
            "Building with a value of 1 instead.")
    NUM_COMPILE_THREADS = 1
}

// Check that Gradle 2.11 is in use, error if < 2.9.
if (gradle.gradleVersion != "2.11") {
    def ver = gradle.gradleVersion.split("[\\.]");
    def gradleMajor = Integer.parseInt(ver[0]);
    def gradleMinor = Integer.parseInt(ver[1]);
    def err = "";
    if (gradleMajor == 1 || gradleMajor == 2 && gradleMinor < 9) {
        err = "Gradle version too old: ${gradle.gradleVersion}; must be at least 2.9"
    }

    if (IS_GRADLE_VERSION_CHECK && err != "") {
        fail(err);
    }

    logger.warn("*****************************************************************");
    logger.warn("Unsupported gradle version $gradle.gradleVersion in use.");
    logger.warn("Only version 2.11 is supported. Use this version at your own risk");
    if ( err != "") logger.warn(err);
    logger.warn("*****************************************************************");
}

/******************************************************************************
 *                                                                            *
 *                      Logging of Properties and Settings                    *
 *                                                                            *
 *  Log some of the settings we've determined. We could log more here, it     *
 *  doesn't really hurt.                                                      *
 *                                                                            *
 *****************************************************************************/

logger.quiet("gradle.gradleVersion: $gradle.gradleVersion")
logger.quiet("OS_NAME: $OS_NAME")
logger.quiet("OS_ARCH: $OS_ARCH")
logger.quiet("JAVA_HOME: $JAVA_HOME")
logger.quiet("JDK_HOME: $JDK_HOME")
logger.quiet("JIGSAW_HOME: $JIGSAW_HOME")
logger.quiet("java.runtime.version: ${javaRuntimeVersion}")
logger.quiet("java version: ${javaVersion}")
logger.quiet("java build number: ${javaBuildNumber}")
logger.quiet("jdk.runtime.version: ${jdkRuntimeVersion}")
logger.quiet("jdk version: ${jdkVersion}")
logger.quiet("jdk build number: ${jdkBuildNumber}")
logger.quiet("minimum jdk version: ${jfxBuildJdkVersionMin}")
logger.quiet("minimum jdk build number: ${jfxBuildJdkBuildnumMin}")
logger.quiet("STUB_RUNTIME: $STUB_RUNTIME")
logger.quiet("CONF: $CONF")
logger.quiet("NUM_COMPILE_THREADS: $NUM_COMPILE_THREADS")
logger.quiet("COMPILE_TARGETS: $COMPILE_TARGETS")
logger.quiet("COMPILE_FLAGS_FILES: $COMPILE_FLAGS_FILES")
logger.quiet("HUDSON_JOB_NAME: $HUDSON_JOB_NAME")
logger.quiet("HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER")
logger.quiet("PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER")
logger.quiet("PRODUCT_NAME: $PRODUCT_NAME")
logger.quiet("RELEASE_VERSION: $RELEASE_VERSION")
logger.quiet("RELEASE_SUFFIX: $RELEASE_SUFFIX")
logger.quiet("RELEASE_VERSION_SHORT: $RELEASE_VERSION_SHORT")
logger.quiet("RELEASE_VERSION_LONG: $RELEASE_VERSION_LONG")
logger.quiet("RELEASE_VERSION_PADDED: $RELEASE_VERSION_PADDED")

if (UPDATE_STUB_CACHE) {
    logger.quiet("UPDATE_STUB_CACHE: $UPDATE_STUB_CACHE")
}

/******************************************************************************
 *                                                                            *
 *                Definition of Native Code Compilation Tasks                 *
 *                                                                            *
 *    - JavaHeaderTask is used to run javah. The JAVAH property will point at *
 *      the version of javah to be used (i.e.: a path to javah)               *
 *    - CCTask compiles native code. Specifically it will compile .m, .c,     *
 *      .cpp, or .cc files. It uses the headers provided by the               *
 *      JavaHeaderTask plus additional platform specific headers. It will     *
 *      compile into .obj files.                                              *
 *    - LinkTask will perform native linking and create the .dll / .so /      *
 *      .dylib as necessary.                                                  *
 *                                                                            *
 *****************************************************************************/

// Save a reference to the buildSrc.jar file because we need it for actually
// compiling things, not just for the sake of this build script
// (such as generating the JSL files, etc)
ext.BUILD_SRC = rootProject.files("buildSrc/build/libs/buildSrc.jar")

/**
 * Convenience method for creating javah, cc, link, and "native" tasks in the given project. These
 * tasks are parameterized by name, so that we can produce, for example, javahGlass, ccGlass, etc
 * named tasks.
 *
 * @param project The project to add tasks to
 * @param name The name of the project, such as "prism-common". This name is used
 *        in the name of the generated task, such as ccPrismCommon, and also
 *        in the name of the final library, such as libprism-common.dylib.
 */
void addNative(Project project, String name) {
    // TODO if we want to handle 32/64 bit windows in the same build,
    // Then we will need to modify the win compile target to be win32 or win64
    def capitalName = name.split("-").collect{it.capitalize()}.join()
    def nativeTask = project.task("native$capitalName", group: "Build") {
        description = "Generates JNI headers, compiles, and builds native dynamic library for $name for all compile targets"
    }
    def cleanTask = project.task("cleanNative$capitalName", type: Delete, group: "Build") {
        description = "Clean native objects for $name"
    }
    if (project.hasProperty("nativeAllTask")) project.nativeAllTask.dependsOn nativeTask
    project.assemble.dependsOn(nativeTask)
    if (project.hasProperty("cleanNativeAllTask")) project.cleanNativeAllTask.dependsOn cleanTask

    // Each of the different compile targets will be placed in a sub directory
    // of these root dirs, with the name of the dir being the name of the target
    def headerRootDir = project.file("$project.buildDir/generated-src/headers/$name")
    def nativeRootDir = project.file("$project.buildDir/native/$name")
    def libRootDir = project.file("$project.buildDir/libs/$name")
    // For each compile target, create a javah / cc / link triplet
    compileTargets { t ->
        def targetProperties = project.rootProject.ext[t.upper]
        def library = targetProperties.library
        def properties = targetProperties.get(name)
        def nativeDir = file("$nativeRootDir/${t.name}")
        def headerDir = file("$headerRootDir/${t.name}")

        // If there is not a library clause in the properties, assume it is not wanted
        if (!targetProperties.containsKey(name)) {
            println("Ignoring native library ${name}. Not defined in ${t.name} project properties");
            return
        }

        // check for the property disable${name} = true
        def String disableKey = "disable${name}"
        def boolean disabled = targetProperties.containsKey(disableKey) ? targetProperties.get(disableKey) : false
        if (disabled) {
            println("Native library ${name} disabled in ${t.name} project properties");
            return
        }

        def javahTask = project.task("javah${t.capital}${capitalName}", type: JavaHeaderTask, dependsOn: project.classes, group: "Build") {
            description = "Generates JNI Headers for ${name} for ${t.name}"
            if (properties.javahSource == null) {
                source(project.sourceSets.main.output.classesDir)
            } else {
                source(properties.javahSource)
            }
            if (properties.javahClasspath == null) {
                classpath = project.files(project.sourceSets.main.output.classesDir)
                classpath += project.sourceSets.main.compileClasspath
            } else {
                classpath = project.files(properties.javahClasspath)
            }
            output = headerDir
            include(properties.javahInclude)
            cleanTask.delete headerDir
        }

        def variants = properties.containsKey("variants") ? properties.variants : [""];
        variants.each { variant ->
            def variantProperties = variant == "" ? properties : properties.get(variant)
            def capitalVariant = variant.capitalize()
            def ccOutput = variant == "" ? nativeDir : file("$nativeDir/$variant")
            def ccTask = project.task("cc${t.capital}$capitalName$capitalVariant", type: CCTask, dependsOn: javahTask, group: "Build") {
                description = "Compiles native sources for ${name} for ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}"
                matches = ".*\\.c|.*\\.cpp|.*\\.m|.*\\.cc"
                headers = headerDir
                output(ccOutput)
                params.addAll(variantProperties.ccFlags)
                compiler = variantProperties.compiler
                source(variantProperties.nativeSource)
                cleanTask.delete ccOutput
            }
            def linkTask = project.task("link${t.capital}$capitalName$capitalVariant", type: LinkTask, dependsOn: ccTask, group: "Build") {
                description = "Creates native dynamic library for $name for ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}"
                objectDir = ccOutput
                linkParams.addAll(variantProperties.linkFlags)
                lib = file("$libRootDir/${t.name}/${variant == '' ? library(properties.lib) : library(variantProperties.lib)}")
                linker = variantProperties.linker
                cleanTask.delete "$libRootDir/${t.name}"
            }
            nativeTask.dependsOn(linkTask)
            if (IS_WINDOWS && t.name == "win") {
                def rcTask = project.task("rc$capitalName$capitalVariant", type: CompileResourceTask, dependsOn: javahTask, group: "Build") {
                    description = "Compiles native sources for $name"
                    matches = ".*\\.rc"
                    compiler = variantProperties.rcCompiler
                    source(variantProperties.rcSource)
                    if (variantProperties.rcFlags) {
                        rcParams.addAll(variantProperties.rcFlags)
                    }
                    output(ccOutput)
                }
                linkTask.dependsOn rcTask;
            }
        }

        def useLipo = targetProperties.containsKey('useLipo') ? targetProperties.useLipo : false
        if (useLipo) {
            def lipoTask = project.task("lipo${t.capital}$capitalName", type: LipoTask, dependsOn: javahTask, group: "Build") {
                description = "Creates native fat library for $name for ${t.name}"
                libDir = file("$libRootDir/${t.name}")
                lib = file("$libRootDir/${t.name}/${library(properties.lib)}")
            }
            nativeTask.dependsOn(lipoTask)
        }
    }
}

void addJSL(Project project, String name, String pkg, Closure compile) {
    def lowerName = name.toLowerCase()

    def compileCompilers = project.task("compile${name}Compilers", type: JavaCompile, dependsOn: project.compileJava) {
        description = "Compile the $name JSL Compilers"
        classpath = project.files(project.sourceSets.main.output.classesDir) +
                rootProject.BUILD_SRC +
                project.configurations.antlr3
        source = [project.file("src/main/jsl-$lowerName")]
        destinationDir = project.file("$project.buildDir/classes/jsl-compilers/$lowerName")
    }

    def generateShaders = project.task("generate${name}Shaders", dependsOn: compileCompilers) {
        description = "Generate $name shaders from JSL"
        def sourceDir = project.file("src/main/jsl-$lowerName")
        def destinationDir = project.file("$project.buildDir/generated-src/jsl-$lowerName")
        inputs.dir sourceDir
        outputs.dir destinationDir
        doLast {
            compile(sourceDir, destinationDir)
        }
    }

    project.task("compile${name}JavaShaders", type: JavaCompile, dependsOn: generateShaders) {
        description = "Compile the Java $name JSL shaders"
        classpath = project.files(project.sourceSets.main.output.classesDir) + rootProject.BUILD_SRC
        source = [project.file("$project.buildDir/generated-src/jsl-$lowerName")]
        destinationDir = project.file("$project.buildDir/classes/jsl-$lowerName")
    }

    def compileHLSLShaders = project.task("compile${name}HLSLShaders", dependsOn: generateShaders, type: CompileHLSLTask) {
        enabled = IS_WINDOWS
        description = "Compile $name HLSL files into .obj files"
        matches = ".*\\.hlsl"
        output project.file("$project.buildDir/hlsl/$name/$pkg")
        source project.file("$project.buildDir/generated-src/jsl-$lowerName/$pkg")
    }

    project.task("process${name}Shaders", dependsOn: [generateShaders, compileHLSLShaders], type: Copy, description: "Copy hlsl / frag shaders to build/resources/jsl-$lowerName") {
        from("$project.buildDir/hlsl/$name") {
            include "**/*.obj"
        }
        from("$project.buildDir/generated-src/jsl-$lowerName") {
            include("**/*.frag")
        }
        into "$project.buildDir/resources/jsl-$lowerName"
    }
}

/**
 * Parses a JDK version string. The string must be in one of the following
 * two formats:
 *
 *     major.minor.subminor
 * or
 *     major.minor.subminor_update
 *
 * In both cases a list of 4 integers is returned, with element 3 set to
 * 0 in the former case.
 */
List parseJdkVersion(String version) {
    def arr = version.split("[_\\.]");
    def intArr = [];
    arr.each { s -> intArr += Integer.parseInt(s); }
    while (intArr.size() < 4) intArr += 0;
    return intArr;
}

/**
 * Returns -1, 0, or 1 depending on whether JDK version "a" is less than,
 * equal to, or grater than version "b".
 */
int compareJdkVersion(String a, String b) {
    def aIntArr = parseJdkVersion(a);
    def bIntArr = parseJdkVersion(b);

    for (int i = 0; i < 4; i++) {
        if (aIntArr[i] < bIntArr[i]) return -1;
        if (aIntArr[i] > bIntArr[i]) return  1;
    }
    return 0;
}

// Task to verify the minimum level of Java needed to build JavaFX
task verifyJava() {
    doLast {
        def status = compareJdkVersion(jdkVersion, jfxBuildJdkVersionMin);
        if (status < 0) {
            fail("java version mismatch: JDK version (${jdkVersion}) < minimum version (${jfxBuildJdkVersionMin})")
        } else if (status == 0) {
            def buildNum = Integer.parseInt(jdkBuildNumber)
            def minBuildNum = Integer.parseInt(jfxBuildJdkBuildnumMin)
            if (buildNum != 0 && buildNum < minBuildNum) {
                fail("JDK build number ($buildNum) < minimum build number ($minBuildNum)")
            }
        }
    }
}

// Task to check whether jfxrt.jar is present in the JDK
task checkJfxrtJar {
    doLast {
        // The following path is correct when using 8u as boot jdk
        def jfxrtFile = new File("$JDK_HOME/jre/lib/ext/jfxrt.jar");
        if (jfxrtFile.exists()) {
            fail("$jfxrtFile must be removed before building sdk")
        }
        // The following path is correct when using 9 (pre-jigsaw) as boot jdk
        jfxrtFile = new File("$JDK_HOME/lib/jfxrt.jar");
        if (jfxrtFile.exists()) {
            fail("$jfxrtFile must be removed before building sdk")
        }
    }
}

task updateCacheIfNeeded() {
    // an empty task we can add to as needed for UPDATE_STUB_CACHE
}

/*****************************************************************************
*        Project definitions (dependencies, etc)                             *
*****************************************************************************/

void addJCov(p, test) {
    test.doFirst {
        def jcovJVMArgument =
                "include=javafx," +
                "include=com.sun.javafx," +
                "include=com.sun.glass," +
                "include=com.sun.openpisces," +
                "include=com.sun.pisces," +
                "include=com.sun.prism," +
                "include=com.sun.scenario," +
                "include=com.sun.webkit," +
                "exclude=com," +
                "exclude=java," +
                "exclude=javax," +
                "exclude=\"**.test\"," +
                "exclude=\"**.*Test\"," +
                "file=build/reports/jcov/report.xml," +
                "merge=merge";
        test.jvmArgs("-javaagent:${p.configurations.testCompile.files.find { it.name.startsWith('jcov') }}=$jcovJVMArgument");
        p.mkdir p.file("build/reports/jcov")
    }
    test.doLast {
        def reportFile = p.file("build/reports/jcov/report.xml")
        if (reportFile.exists()) {
            p.javaexec {
                workingDir = p.file("build/reports/jcov")
                classpath = p.files(p.configurations.testCompile.files.find { it.name.startsWith('jcov') })
                main = "com.sun.tdk.jcov.Helper"
                args = [
                        "RepGen",
                        "-exclude", "\"**.test\"",
                        "-exclude", "\"**.*Test\"",
                        "-output", ".",
                        "-source", p.sourceSets.main.java.srcDirs.collect{p.file(it)}.join(":"),
                        "report.xml"
                ]
            }
        }
    }
}

allprojects {
    // We want to configure all projects as java projects and use the same compile settings
    // etc, except for the root project which we just want to ignore (and for now media)
    if (project == rootProject) {
       return
    }
    if (project.path.startsWith(":apps")) {
        // Lets handle the apps tree differently, as it is a collection of ant builds,
        // and the ant importer collides with the 'apply plugin:java'
        return
    }
    // All of our projects are java projects
    apply plugin: "java"
    sourceCompatibility = 1.8

    // Setup the repositories that we'll download libraries from. Maven Central is
    // just easy for most things. The custom "ivy" repo is for downloading SWT. The way it
    // works is to setup the download URL such that it will resolve to the actual jar file
    // to download. See SWT_FILE_NAME for the name of the jar that will be used as the
    // "artifact" in the pattern below. Note that the closed builds use different repositories
    // so if you are debugging a closed-build artifact related build issue, check out the
    // closed gradle file instead.
    if (!BUILD_CLOSED) {
        repositories {
            mavenCentral()
            ivy {
                url "http://download.eclipse.org/eclipse/updates/3.7/R-3.7.2-201202080800/plugins/"
                layout "pattern", {
                    artifact "[artifact].[ext]"
                }
            }
        }
    }

    // By default all of our projects require junit for testing so we can just
    // setup this dependency here.
    dependencies {
        testCompile group: "junit", name: "junit", version: "4.8.2"
        if (BUILD_CLOSED && DO_JCOV)  {
            testCompile name: "jcov"
        }
    }

    // Compile and run tests against the jfxrt.jar in the built sdk of the host machine
    def sdkDir = "${rootProject.buildDir}/sdk"
    def jfxrtJar = "$sdkDir/lib/jfxrt.jar"
    def testJfxrtJar = DO_BUILD_SDK_FOR_TEST ? jfxrtJar : jfxrtJarFromSdk

    // At the moment the ASM library shipped with Gradle that is used to
    // discover the different test classes fails on Java 8, so in order
    // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off
    // and manually specify the includes / excludes. At the moment we use
    // Java 7 but when we switch to 8 this will be needed, and probably again when
    // we start building with Java 9.
    test {
        executable = JAVA;
        enableAssertions = true;
        testLogging.exceptionFormat = "full";
        scanForTestClasses = false;
        include("**/*Test.*");
        if (BUILD_CLOSED && DO_JCOV) {
            addJCov(project, test)
        }
        classpath = files(testJfxrtJar) + classpath
        if (IS_HEADLESS_TEST) {
            systemProperty 'glass.platform', 'Monocle'
            systemProperty 'monocle.platform', 'Headless'
            systemProperty 'prism.order', 'sw'
            systemProperty 'com.sun.javafx.gestures.zoom', 'true'
            systemProperty 'com.sun.javafx.gestures.rotate', 'true'
            systemProperty 'com.sun.javafx.gestures.scroll', 'true'
        }

        systemProperty 'unstable.test', IS_UNSTABLE_TEST
    }

    compileTestJava {
        classpath = files(testJfxrtJar) + classpath
    }

    // Exclude any non-public-API classes from having javadoc generated. This block is used
    // when generating JavaDocs for a specific project. When generating the JavaDocs for the
    // entire SDK, a different javadoc command is used (see the javadoc task on the top level)
    javadoc {
        enabled = IS_BUILD_JAVADOC
        exclude("com/**/*", "Compile*", "javafx/builder/**/*", "javafx/scene/accessibility/**/*");
        executable = JAVADOC;
        options.windowTitle("JavaFX Project ${project.name} ${RELEASE_VERSION}")
        if (BUILD_CLOSED) {
            options.linksOffline(JDK_DOCS, JDK_DOCS_CLOSED);
        } else {
            options.links(JDK_DOCS);
        }
        options.addBooleanOption("XDignore.symbol.file").setValue(true);
        options.addBooleanOption("Xdoclint:none").setValue(!IS_DOC_LINT);
        options.addBooleanOption("javafx").setValue(true);
        options.addBooleanOption("use").setValue(true);
        // All doc-files are located in src/main/docs because Gradle's javadoc doesn't copy
        // over the doc-files if they are embedded with the sources. I find this arrangement
        // somewhat cleaner anyway (never was a fan of mixing javadoc files with the sources)
        doLast {
            copy {
                from "src/main/docs"
                into "$buildDir/docs/javadoc"
            }
        }
    }
}

// The "base" project is our first module and the most basic one required for
// all other modules. It is useful even for non-GUI applications.
project(":base") {
    project.ext.buildModule = true
    project.ext.moduleRuntime = true
    project.ext.moduleName = "javafx.base"

    Set<String> testInclude = [ "test/**" ]
    configureJigsawTests(project, null,
        null, testInclude,
        project.projectDir.path + "/src/test/addExports"
        )

    dependencies {
        compile BUILD_SRC
    }

    // We need to take the VersionInfo.java file and replace the various
    // properties within it
    def replacements = [
        "BUILD_TIMESTAMP": BUILD_TIMESTAMP,
        "HUDSON_JOB_NAME": HUDSON_JOB_NAME,
        "HUDSON_BUILD_NUMBER": HUDSON_BUILD_NUMBER,
        "PROMOTED_BUILD_NUMBER": PROMOTED_BUILD_NUMBER,
        "PRODUCT_NAME": PRODUCT_NAME,
        "RELEASE_VERSION": RELEASE_VERSION,
        "RELEASE_SUFFIX": RELEASE_SUFFIX];
    task processVersionInfo(type: Copy, description: "Replace params in VersionInfo and copy file to destination") {
        doFirst { mkdir "$buildDir/generated-src/version-info" }
        from "src/main/version-info"
        into "$buildDir/generated-src/version-info/com/sun/javafx/runtime"
        filter {line->
            replacements.each() {k, v ->
                line = line.replace("@$k@", v.toString());
            }
            line
        }
    }

    compileJava.dependsOn updateCacheIfNeeded
    compileJava.dependsOn verifyJava

    // Make sure to include $buildDir/generated-src/version-info that we previously created.
    // We DO NOT want to include src/main/version-info
    if (System.getProperty("jfx.build.jdk.defenders", "true").equals("true")) {
        sourceSets.main.java.srcDirs += "src/main/java8"
    } else {
        sourceSets.main.java.srcDirs += "src/main/java7"
    }

    if (IS_COMPILE_JFR) {
        sourceSets.main.java.srcDirs += "src/main/java-jfr"
    }

    sourceSets.main.java.srcDirs += "$buildDir/generated-src/version-info"

    compileJava.dependsOn processVersionInfo
}

// The graphics module is needed for any graphical JavaFX application. It requires
// the base module and includes the scene graph, layout, css, prism, windowing, etc.
// This is a fairly complicated module. There are many different types of native components
// that all need to be compiled.
project(":graphics") {
    // Workaround for lack of Antlr 3 support in Gradle. By defining a configuration,
    // we can then give it a class path and use that classpath to execute a java command
    getConfigurations().create("antlr3");

    sourceSets {
        main
        test
        stub
    }

    project.ext.buildModule = true
    project.ext.moduleRuntime = true
    project.ext.moduleName = "javafx.graphics"

    Set<String> testInclude = [ "test/**" ]
    configureJigsawTests(project, [ "base" ],
        null, testInclude,
        project.projectDir.path + "/src/test/addExports"
        )

    project.ext.extraBuildDirs = [
        "${buildDir}/classes/jsl-decora",
        "${buildDir}/resources/jsl-decora",
        "${buildDir}/classes/jsl-prism",
        "${buildDir}/resources/jsl-prism"
    ]

    dependencies {
        compile project(":base"), BUILD_SRC
        stubCompile group: "junit", name: "junit", version: "4.8.2",
        project(":base").sourceSets.test.output, sourceSets.main.output
        antlr3 group: "org.antlr", name: "antlr", version: "3.1.3"
        antlr3 group: "org.antlr", name: "antlr-runtime",  version: "3.1.3"
        antlr3 group: "org.antlr", name: "stringtemplate", version: "3.2"
    }

    // Create a single "native" task which will depend on all the individual native tasks for graphics
    project.ext.nativeAllTask = task("native", group: "Build", description: "Compiles and Builds all native libraries for Graphics");
    project.ext.cleanNativeAllTask = task("cleanNative", group: "Build", description: "Clean all native libraries and objects for Graphics");

    // Add tasks for native compilation
    addNative(project, "glass");
    addNative(project, "prism")
    addNative(project, "prismSW")
    addNative(project, "font")
    addNative(project, "iio")
    addNative(project, "prismES2")

    if (IS_COMPILE_PANGO) {
        addNative(project, "fontFreetype")
        addNative(project, "fontPango")
    }

    if (IS_WINDOWS) {
        addNative(project, "prismD3D")
        // TODO need to hook this up to be executed only if PassThroughVS.h is missing or PassThroughVS.hlsl is changed
        task generateD3DHeaders(group: "Build") {
            enabled = IS_WINDOWS
            dependsOn javahWinPrismD3D
            inputs.file "src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl"
            inputs.file "src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl"
            inputs.file "src/main/native-prism-d3d/PassThroughVS.hlsl"
            outputs.dir "$buildDir/headers/PrismD3D/"
            outputs.dir "$buildDir/headers/PrismD3D/hlsl/"
            description = "Generate headers by compiling hlsl files"
            doLast {
                mkdir file("$buildDir/headers/PrismD3D/hlsl")
                def PS_3D_SRC = file("src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl")
                def VS_3D_SRC = file("src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl")
                def PASSTHROUGH_VS_SRC = file("src/main/native-prism-d3d/PassThroughVS.hlsl")
                def jobs = [
                        ["$FXC", "/nologo", "/T", "vs_3_0", "/Fh", "$buildDir/headers/PrismD3D/PassThroughVS.h", "/E", "passThrough", "$PASSTHROUGH_VS_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS.h", "/DSpec=0", "/DSType=0", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_i.h", "/DSpec=0", "/DSType=0", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1n.h", "/DSpec=1", "/DSType=0", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2n.h", "/DSpec=2", "/DSType=0", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3n.h", "/DSpec=3", "/DSType=0", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1t.h", "/DSpec=1", "/DSType=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2t.h", "/DSpec=2", "/DSType=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3t.h", "/DSpec=3", "/DSType=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1c.h", "/DSpec=1", "/DSType=2", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2c.h", "/DSpec=2", "/DSType=2", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3c.h", "/DSpec=3", "/DSType=2", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1m.h", "/DSpec=1", "/DSType=3", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2m.h", "/DSpec=2", "/DSType=3", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3m.h", "/DSpec=3", "/DSType=3", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1n.h", "/DSpec=1", "/DSType=0", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2n.h", "/DSpec=2", "/DSType=0", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3n.h", "/DSpec=3", "/DSType=0", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1t.h", "/DSpec=1", "/DSType=1", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2t.h", "/DSpec=2", "/DSType=1", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3t.h", "/DSpec=3", "/DSType=1", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1c.h", "/DSpec=1", "/DSType=2", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2c.h", "/DSpec=2", "/DSType=2", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3c.h", "/DSpec=3", "/DSType=2", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1m.h", "/DSpec=1", "/DSType=3", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2m.h", "/DSpec=2", "/DSType=3", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3m.h", "/DSpec=3", "/DSType=3", "/DBump=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ni.h", "/DSpec=1", "/DSType=0", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ni.h", "/DSpec=2", "/DSType=0", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ni.h", "/DSpec=3", "/DSType=0", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ti.h", "/DSpec=1", "/DSType=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ti.h", "/DSpec=2", "/DSType=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ti.h", "/DSpec=3", "/DSType=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ci.h", "/DSpec=1", "/DSType=2", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ci.h", "/DSpec=2", "/DSType=2", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ci.h", "/DSpec=3", "/DSType=2", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1mi.h", "/DSpec=1", "/DSType=3", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2mi.h", "/DSpec=2", "/DSType=3", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3mi.h", "/DSpec=3", "/DSType=3", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ni.h", "/DSpec=1", "/DSType=0", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ni.h", "/DSpec=2", "/DSType=0", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ni.h", "/DSpec=3", "/DSType=0", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ti.h", "/DSpec=1", "/DSType=1", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ti.h", "/DSpec=2", "/DSType=1", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ti.h", "/DSpec=3", "/DSType=1", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ci.h", "/DSpec=1", "/DSType=2", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ci.h", "/DSpec=2", "/DSType=2", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ci.h", "/DSpec=3", "/DSType=2", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1mi.h", "/DSpec=1", "/DSType=3", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2mi.h", "/DSpec=2", "/DSType=3", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "ps_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3mi.h", "/DSpec=3", "/DSType=3", "/DBump=1", "/DIllumMap=1", "$PS_3D_SRC"],
                        ["$FXC", "/nologo", "/T", "vs_2_0", "/Fh", "$buildDir/headers/PrismD3D/hlsl/Mtl1VS_Obj.h", "/DVertexType=ObjVertex", "$VS_3D_SRC"]
                ]
                final ExecutorService executor = Executors.newFixedThreadPool(Integer.parseInt(project.NUM_COMPILE_THREADS.toString()));
                final CountDownLatch latch = new CountDownLatch(jobs.size());
                List futures = new ArrayList<Future>();
                jobs.each { cmd ->
                    futures.add(executor.submit(new Runnable() {
                        @Override public void run() {
                            try {
                                exec {
                                    commandLine cmd
                                }
                            } finally {
                                latch.countDown();
                            }
                        }
                    }));
                }
                latch.await();
                // Looking for whether an exception occurred while executing any of the futures.
                // By calling "get()" on each future an exception will be thrown if one had occurred
                // on the background thread.
                futures.each {it.get();}
            }
        }

        ccWinPrismD3D.dependsOn generateD3DHeaders
    }

    // The Decora and Prism JSL files have to be generated in a very specific set of steps.
    //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be
    //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).
    //      2) Generate source files from the JSL files contained in src/main/jsl-*. These
    //         will be output to $buildDir/generated-src/jsl-*
    //      3) Compile the JSL Java sources in $buildDir/generated-src/jsl-* and put the output
    //         into classes/jsl-*
    //      4) Compile the native JSL sources in $buildDir/generated-src/jsl-* and put the obj
    //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib
    //      5) Modify the jar step to include classes/jsl-*
    // The native library must be copied over during SDK creation time in the "sdk" task. In
    // addition to these steps, the clean task is created. Note that I didn't bother to create
    // a new task for each of the decora files, preferring instead just to create a rule?? Also
    // need "clean" tasks for each compile task.

    addJSL(project, "Decora", "com/sun/scenario/effect/impl/hw/d3d/hlsl") { sourceDir, destinationDir ->
        [[fileName: "ColorAdjust", generator: "CompileJSL", outputs: "-all"],
         [fileName: "Brightpass", generator: "CompileJSL", outputs: "-all"],
         [fileName: "SepiaTone", generator: "CompileJSL", outputs: "-all"],
         [fileName: "PerspectiveTransform", generator: "CompileJSL", outputs: "-all"],
         [fileName: "DisplacementMap", generator: "CompileJSL", outputs: "-all"],
         [fileName: "InvertMask", generator: "CompileJSL", outputs: "-all"],
         [fileName: "Blend", generator: "CompileBlend", outputs: "-all"],
         [fileName: "PhongLighting", generator: "CompilePhong", outputs: "-all"],
         [fileName: "LinearConvolve", generator: "CompileLinearConvolve", outputs: "-hw"],
         [fileName: "LinearConvolveShadow", generator: "CompileLinearConvolve", outputs: "-hw"]].each { settings ->
            javaexec {
                executable = JAVA
                workingDir = "modules/graphics"
                main = settings.generator
                classpath = configurations.compile + configurations.antlr3
                classpath += files("$buildDir/classes/main")
                classpath += files("$buildDir/classes/jsl-compilers/decora")
                args = ["-i", sourceDir, "-o", destinationDir, "-t", "-pkg", "com/sun/scenario/effect", "$settings.outputs", "$settings.fileName"]
            }
        }
    }

    task generateDecoraNativeHeaders(type: JavaHeaderTask, dependsOn: compileDecoraJavaShaders) {
        description = "Generates JNI Headers for Decora SSE Natives"
        source file("$buildDir/classes/jsl-decora")
        source file("$buildDir/classes/main")
        include("com/sun/scenario/effect/impl/sw/sse/*");
        classpath = files("$buildDir/classes/main", "$buildDir/classes/jsl-decora")
        output = file("$buildDir/generated-src/headers/jsl-decora")
    }

    task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: "Build") {
        description = "Generates JNI headers, compiles, and builds native dynamic library for Decora"
    }
    task cleanNativeDecora(type: Delete, group: "Build") {
        description = "Clean native objects for Decora"
    }

    def headerDir = file("$buildDir/generated-src/headers/jsl-decora")
    def nativeRootDir = project.file("$project.buildDir/native/jsl-decora")
    def libRootDir = project.file("$project.buildDir/libs/jsl-decora")
    // For each compile target, create cc and link tasks
    compileTargets { t ->
        def target = t.name
        def upperTarget = t.upper
        def capitalTarget = t.capital
        def targetProperties = rootProject.ext[upperTarget];
        def library = targetProperties.library
        def properties = targetProperties.get('decora')
        def nativeDir = file("$nativeRootDir/$target");

        def variants = properties.containsKey("variants") ? properties.variants : [""];
        variants.each { variant ->
            def variantProperties = variant == "" ? properties : properties.get(variant)
            def capitalVariant = variant.capitalize()
            def ccOutput = variant == "" ? nativeDir : file("$nativeDir/$variant")

            def ccTask = task("compileDecoraNativeShaders$capitalTarget$capitalVariant", type: CCTask, dependsOn: generateDecoraNativeHeaders) {
                description = "Compiles Decora SSE natives for ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}"
                matches = ".*\\.cc"
                source file("$buildDir/generated-src/jsl-decora")
                source file("modules/graphics/src/main/native-decora")
                headers = headerDir
                params.addAll(variantProperties.ccFlags)
                output(ccOutput)
                compiler = variantProperties.compiler
                cleanNativeDecora.delete ccOutput
            }

            def linkTask = task("linkDecoraNativeShaders$capitalTarget$capitalVariant", type: LinkTask, dependsOn: ccTask) {
                description = "Creates native dynamic library for Decora SSE ${t.name}${capitalVariant != '' ? ' for variant ' + capitalVariant : ''}"
                objectDir = ccOutput
                linkParams.addAll(variantProperties.linkFlags)
                lib = file("$libRootDir/$t.name/${library(variantProperties.lib)}")
                linker = variantProperties.linker
                cleanNativeDecora.delete "$libRootDir/$t.name/"
            }

            if (IS_WINDOWS && target == "win") {
                def rcTask = project.task("rcDecoraNativeShaders$capitalTarget$capitalVariant", type: CompileResourceTask, dependsOn: generateDecoraNativeHeaders) {
                    description = "Compiles native sources for Decora SSE"
                    matches = ".*\\.rc"
                    compiler = variantProperties.rcCompiler
                    source(variantProperties.rcSource)
                    if (variantProperties.rcFlags) {
                        rcParams.addAll(variantProperties.rcFlags)
                    }
                    output(ccOutput)
                }
                linkTask.dependsOn rcTask;
            }

            nativeDecora.dependsOn(linkTask)
        }
    }

    // Prism JSL
    addJSL(project, "Prism", "com/sun/prism/d3d/hlsl") { sourceDir, destinationDir ->
        def inputFiles = fileTree(dir: sourceDir)
        inputFiles.include "**/*.jsl"
        inputFiles.each { file ->
            javaexec {
                executable = JAVA
                workingDir = "modules/graphics"
                main = "CompileJSL"
                classpath = configurations.compile + configurations.antlr3
                classpath += files("$buildDir/classes/jsl-compilers/prism", "modules/graphics/src/main/jsl-prism") // for the .stg
                args = ["-i", sourceDir, "-o", destinationDir, "-t", "-pkg", "com/sun/prism", "-d3d", "-es2", "-name", "$file"]
            }
        }
    }

    classes.dependsOn compilePrismJavaShaders;
    nativePrism.dependsOn compilePrismHLSLShaders;

    project.nativeAllTask.dependsOn nativeDecora
    project.cleanNativeAllTask.dependsOn cleanNativeDecora
    assemble.dependsOn nativeDecora
    processResources.dependsOn processDecoraShaders, processPrismShaders

    test {
        def cssDir = file("$buildDir/classes/main/javafx")
        jvmArgs "-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit",
            "-DCSS_META_DATA_TEST_DIR=$cssDir"
        enableAssertions = true
        testLogging.exceptionFormat = "full"
        scanForTestClasses = false
        include "**/*Test.*"
        if (BUILD_CLOSED && DO_JCOV) {
            addJCov(project, test)
        }
    }

    // To enable the IDEs to all be happy (no red squiggles) we need to have the libraries
    // available in some known location. Maybe in the future the Gradle plugins to each
    // of the IDEs will be good enough that we won't need this hack anymore.
    classes << {
        // Copy all of the download libraries to the libs directory for the sake of the IDEs
        File libsDir = rootProject.file("build/libs");

        // In some IDEs (Eclipse for example), touching these libraries
        // cauese a full build within the IDE. When gradle is used
        // outside of the IDE, for example to build the native code,
        // a full rebuild is caused within the IDE. The fix is to check
        // for the presence of the target files in the lib directory
        // and not copy the files if all are present.

        libsDir.mkdirs();

        def allLibsPresent = true
        def libNames = ["antlr-3.1.3.jar", "stringtemplate-3.2.jar", "antlr-runtime-3.1.3.jar"]
        libNames.each { name ->
            File f = new File(libsDir, name)
            if (!f.exists()) allLibsPresent = false
        }
        if (allLibsPresent) return;

        for (File f : [configurations.compile.files, configurations.antlr3.files].flatten()) {
            copy {
                into libsDir
                from f.getParentFile()
                include "**/antlr-3.1.3.jar"
                include "**/stringtemplate-3.2.jar"
                include "**/antlr-runtime-3.1.3.jar"
                includeEmptyDirs = false
            }
        }
    }
}

project(":controls") {
    project.ext.buildModule = true
    project.ext.moduleRuntime = true
    project.ext.moduleName = "javafx.controls"

    Set<String> testInclude = [ "test/**" ]
    configureJigsawTests(project, [ "base", "graphics" ],
        null, testInclude,
        project.projectDir.path + "/src/test/addExports"
    )

    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics")
        // TODO not sure how to specify this? processResources project(":base"), project(":graphics")
        testCompile project(":graphics").sourceSets.test.output
        testCompile project(":base").sourceSets.test.output
    }

    test {
        def cssDir = file("$buildDir/classes/main/javafx")
        jvmArgs "-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit",
            "-DCSS_META_DATA_TEST_DIR=$cssDir"
    }

    // TODO Css2Bin really should be moved out and put into buildSrc if it can be
    // TODO could change script to dynamically locate all .css files and create bss for them, probably better
    // TODO also not sure there is any benefit to having css files in the jfxrt.jar at all
    processResources << {
        ["$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/caspian.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/caspian-no-transparency.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/embedded-qvga.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/embedded.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/fxvk.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/caspian/highcontrast.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/modena/modena.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/modena/modena-no-transparency.css",
        "$buildDir/resources/main/com/sun/javafx/scene/control/skin/modena/touch.css"].each { css ->
            javaexec {
                executable = JAVA
                workingDir = "modules/controls"
                classpath files("$buildDir/classes/main",
                        project(":graphics").sourceSets.main.output,
                        project(":base").sourceSets.main.output)
                main = "com.sun.javafx.css.parser.Css2Bin"
                args css
            }
        }
    }
}

project(":extensions") {
    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics")
    }
}

project(":swing") {
    /* should not be built, but needed in JMX
    tasks.all {
        if (!COMPILE_SWING) it.enabled = false
    }
    */
    project.ext.buildModule = COMPILE_SWING
    project.ext.moduleRuntime = true
    project.ext.moduleName = "javafx.swing"

    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics")
    }

    Set<String> testInclude = [ "test/**" ]
    configureJigsawTests(project, [ "base", "graphics", "controls" ],
        null, testInclude,
        null // no addExports
    )

    test {
        enabled = IS_FULL_TEST && IS_AWT_TEST
    }
}

project(":swt") {
    tasks.all {
        if (!COMPILE_SWT) it.enabled = false
    }
    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics")
        compile name: SWT_FILE_NAME
    }
    classes << {
        // Copy all of the download libraries to libs directory for the sake of the IDEs
        File libsDir = rootProject.file("build/libs");
        File swtLib = new File(libsDir, "swt-debug.jar")
        libsDir.mkdirs();

        // Skip copy if file is present.
        if (swtLib.exists()) return;

        for (File f : configurations.compile.files) {
            // Have to rename the swt jar because it is some platform specific name but
            // for the sake of the IDEs we need to have a single stable name that works
            // on every platform
            copy {
                into libsDir
                from f.getParentFile()
                include "**/*swt*.jar"
                includeEmptyDirs = false
                rename ".*swt.*jar", "swt-debug\\.jar"
            }
        }
    }
}

project(":fxml") {
    project.ext.buildModule = true
    project.ext.moduleRuntime = true
    project.ext.moduleName = "javafx.fxml"

    Set<String> testInclude = [ "test/**" ]
    configureJigsawTests(project, [ "base", "graphics" ],
        null, testInclude,
        project.projectDir.path + "/src/test/addExports"
    )

    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics"),
                project(":controls"), project(":swt"), project(":swing")
        testCompile project(":graphics").sourceSets.test.output
    }
    test {
        // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance
        // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,
        // we have to use the stub toolkit for now.
        jvmArgs "-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit"
        // FIXME: change this to also allow JDK 9 boot jdk
        classpath += files("$JDK_HOME/jre/lib/ext/nashorn.jar")
    }
}

project(":jmx") {
    project.ext.buildModule = false // true
    project.ext.moduleRuntime = false
    project.ext.moduleName = "javafx.jmx"
    dependencies {
        compile project(":base")
        compile project(":graphics")
        compile project(":swing")
        compile project(":media")
    }

    // Tests are disabled until RT-33926 can be fixed
    test.enabled = false

    if (!DO_BUILD_SDK_FOR_TEST) {
       def javafxMxJar = new File(TEST_SDK_DIR, "lib/javafx-mx.jar")
       [test, compileTestJava].each {
           it.classpath = files(javafxMxJar) + it.classpath
       }
    }
}

project(":fxpackagerservices") {
    project.ext.buildModule = COMPILE_FXPACKAGER
    project.ext.moduleRuntime = false
    project.ext.moduleName = "jdk.packager.services"
    tasks.all {
        if (!COMPILE_FXPACKAGER) it.enabled = false
    }

    test {
        if (IS_JIGSAW_TEST) {
            enabled = false // FIXME: JIGSAW -- support this with modules
            logger.info("JIGSAW Testing disabled for fxpackagerservices")
        }
    }
}

project(":fxpackager") {
    project.ext.buildModule = COMPILE_FXPACKAGER
    project.ext.moduleRuntime = false
    project.ext.moduleName = "jdk.packager"
    tasks.all {
        if (!COMPILE_FXPACKAGER) it.enabled = false
    }

    // fxpackager has a dependency on ant in order to build the ant jar,
    // and as such needs to point to the apache binary repository
    if (!BUILD_CLOSED) {
        repositories {
            maven {
                url "https://repository.apache.org"
            }
        }
    }

    dependencies {
        compile group: "org.apache.ant", name: "ant", version: "1.8.2"
        compile project(":fxpackagerservices")
        testCompile project(":controls")
    }

    // When producing the jar, we need to relocate a few class files
    // from their normal location to a resources/classes or resources/web-files
    // location
    jar {
        includeEmptyDirs = false
        archiveName = "ant-javafx.jar"
        includes = ["com/sun/javafx/tools/ant/**", "com/javafx/main/**"]
        eachFile { FileCopyDetails details ->
            if (details.path.startsWith("com/javafx/main")) {
                details.path = "resources/classes/$details.path"
            }
        }
    }

    // The "man" task will create a $buildDir/man containing the man
    // files for the system being built
    task man(type: Copy) {
        includeEmptyDirs = false
        enabled = (IS_LINUX || IS_MAC) && COMPILE_FXPACKAGER
        from "src/main/man"
        into "$buildDir/man"
        exclude "**/*.html"
        if (IS_MAC) exclude "**/ja_JP.UTF-8/**"
    }
    processResources.dependsOn man

    // Compile the native launchers. These are included in ant-javafx.jar.
    if (IS_WINDOWS && COMPILE_FXPACKAGER) {
        task buildWinLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher";
            matches = "WinLauncher\\.cpp";
            params.addAll(WIN.launcher.ccFlags);
            output(file("$buildDir/native/WinLauncher"));
            source(file("src/main/native/launcher/win"));
            compiler = WIN.launcher.compiler
            exe = true;
            linkerOptions.addAll(WIN.launcher.linkFlags);
            doLast {
                copy {
                    from "$buildDir/native/WinLauncher/WinLauncher.exe"
                    from "$MSVCR"
                    from "$MSVCP"
                    into "$buildDir/classes/main/com/oracle/tools/packager/windows"
                }
            }
        }
        task compileWinLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library";
            matches = ".*\\.cpp"
            source(file("src/main/native/library/common"));
            params.addAll(WIN.launcherlibrary.ccFlags)
            output(file("$buildDir/native/WinLauncher/obj"));
            compiler = WIN.launcherlibrary.compiler
        }
        task linkWinLibrary(type: LinkTask, group: "Build", dependsOn: compileWinLibrary) {
            description = "Links native sources for the application co-bundle launcher library";
            objectDir = file("$buildDir/native/WinLauncher/obj")
            linkParams.addAll(WIN.launcherlibrary.linkFlags);
            lib = file("$buildDir/native/WinLauncher/packager.dll")
            linker = WIN.launcherlibrary.linker
            doLast {
                copy {
                    from "$buildDir/native/WinLauncher/packager.dll"
                    into "$buildDir/classes/main/com/oracle/tools/packager/windows"
                }
            }
        }
        task buildWinLauncherSvc(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher";
            matches = "WinLauncherSvc\\.cpp";
            params.addAll(WIN.launcher.ccFlags);
            output(file("$buildDir/native/WinLauncherSvc"));
            source(file("src/main/native/service/win"));
            compiler = WIN.launcher.compiler
            exe = true;
            linkerOptions.addAll(WIN.launcher.linkFlags);
            doLast {
                copy {
                    from "$buildDir/native/WinLauncherSvc/WinLauncherSvc.exe"
                    into "$buildDir/classes/main/com/oracle/tools/packager/windows"
                }
            }
        }
        task buildIconSwap(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = "IconSwap\\.cpp"
            params.addAll(WIN.iconLauncher.ccFlags)
            output(file("$buildDir/native/IconSwap"))
            source file("src/main/native/tools/win/iconswap")
            compiler = WIN.launcher.compiler
            exe = true
            linkerOptions.addAll(WIN.iconLauncher.linkFlags)
            doLast {
                copy {
                    from "$buildDir/native/IconSwap/IconSwap.exe"
                    into "$buildDir/classes/main/com/oracle/tools/packager/windows"
                }
            }
        }
        task compileVersionInfoSwap(type: CCTask, group: "Build") {
            description = "Compiles native sources for the VersionInfoSwap tool";
            matches = ".*\\.cpp"
            source(file("src/main/native/tools/win/versioninfoswap"));
            params.addAll(WIN.versionInfoLauncher.ccFlags)
            output(file("$buildDir/native/VersionInfoSwap/obj"));
            compiler = WIN.versionInfoLauncher.compiler
        }
        task linkVersionInfoSwap(type: LinkTask, group: "Build", dependsOn: compileVersionInfoSwap) {
            description = "Links native sources for the VersionInfoSwap tool";
            objectDir = file("$buildDir/native/VersionInfoSwap/obj")
            linkParams.addAll(WIN.versionInfoLauncher.linkFlags);
            lib = file("$buildDir/native/VersionInfoSwap/VersionInfoSwap.exe")
            linker = WIN.versionInfoLauncher.linker
            doLast {
                copy {
                    from "$buildDir/native/VersionInfoSwap/VersionInfoSwap.exe"
                    into "$buildDir/classes/main/com/oracle/tools/packager/windows"
                }
            }
        }
        task compileLauncher(dependsOn: [buildWinLauncher, linkWinLibrary, buildWinLauncherSvc, buildIconSwap, linkVersionInfoSwap])
        jar.dependsOn compileLauncher;
    } else if (IS_MAC && COMPILE_FXPACKAGER) {
        task buildMacLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = ".*\\.m"
            source file("src/main/native/launcher/mac")
            params.addAll(MAC.launcher.ccFlags)
            compiler = MAC.launcher.compiler
            output(file("$buildDir/classes/main/com/oracle/tools/packager/mac"))
            outputs.file(file("$buildDir/classes/main/com/oracle/tools/packager/mac/JavaAppLauncher"))
            eachOutputFile = { f ->
                return new File(f.getParent(), "JavaAppLauncher")
            }
        }
        task compileMacLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library"
            matches = ".*\\.cpp|.*\\.mm"
            source file("src/main/native/library/common");
            params.addAll(MAC.launcherlibrary.ccFlags)
            compiler = MAC.launcherlibrary.compiler
            output(file("$buildDir/native/maclauncher/obj"))
        }
        task linkMacLibrary(type: LinkTask, group: "Build", dependsOn: compileMacLibrary) {
            description = "Links native sources for the application co-bundle launcher library"
            objectDir = file("$buildDir/native/maclauncher/obj")
            linkParams.addAll(MAC.launcherlibrary.linkFlags)
            linker = MAC.launcherlibrary.linker
            lib = file("$buildDir/classes/main/com/oracle/tools/packager/mac/libpackager.dylib")
        }
        task compileLauncher(dependsOn: [buildMacLauncher, linkMacLibrary])
        jar.dependsOn compileLauncher;
    } else if (IS_LINUX && COMPILE_FXPACKAGER) {
        task compileLinuxLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = ".*\\.cpp"
            source file("src/main/native/launcher/linux")
            params.addAll(LINUX.launcher.ccFlags)
            compiler = LINUX.launcher.compiler
            output(file("$buildDir/native/linuxlauncher/launcherobj"))
        }
        task linkLinuxLauncher(type: LinkTask, dependsOn: compileLinuxLauncher, group: "Build") {
            description = "Links native dynamic library for the application co-bundle launcher"
            objectDir = file("$buildDir/native/linuxlauncher/launcherobj")
            linkParams.addAll(LINUX.launcher.linkFlags)
            linker = LINUX.launcher.linker
            lib = file("$buildDir/classes/main/com/oracle/tools/packager/linux/JavaAppLauncher")
        }
        task compileLinuxLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library"
            matches = ".*\\.cpp"
            source file("src/main/native/library/common")
            params.addAll(LINUX.launcherlibrary.ccFlags)
            compiler = LINUX.launcherlibrary.compiler
            output(file("$buildDir/native/linuxlauncher/obj"))
        }
        task linkLinuxLibrary(type: LinkTask, dependsOn: compileLinuxLibrary, group: "Build") {
            description = "Links native dynamic library for the application co-bundle launcher library"
            objectDir = file("$buildDir/native/linuxlauncher/obj")
            linkParams.addAll(LINUX.launcherlibrary.linkFlags)
            linker = LINUX.launcherlibrary.linker
            lib = file("$buildDir/classes/main/com/oracle/tools/packager/linux/libpackager.so")
        }
        task compileLauncher(dependsOn: [linkLinuxLauncher, linkLinuxLibrary])
        jar.dependsOn compileLauncher;
    }

    // Builds the javapackager executable. For everything other than windows,
    // this is simply moving the existing shell script and ensuring it has proper
    // permissions. For Windows, this includes compiling the native executable
    if (IS_WINDOWS && COMPILE_FXPACKAGER){
        task buildJavaPackager(type: CCTask, group: "Build") {
            description = "Compiles native sources for javapackager.exe"
            matches = "javapackager\\.cpp"
            params.addAll(WIN.fxpackager.ccFlags)
            compiler = WIN.fxpackager.compiler
            output(file("$buildDir/native/javapackager"))
            source WIN.fxpackager.nativeSource
            doFirst {
                copy {
                    mkdir "$buildDir/native"
                    mkdir "$buildDir/native/javapackager"
                    from file("src/main/native/javapackager/win/javapackager.manifest")
                    into file("$buildDir/native/javapackager")
                    filter { line->
                        line = line.replace("FXVERSION", RELEASE_VERSION_PADDED)
                    }
                }
            }
            doLast {
                mkdir "$buildDir/native"
                exec {
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                    commandLine(WIN.fxpackager.rcCompiler)
                    args(WIN.fxpackager.rcFlags)
                    args("/fo$buildDir/native/javapackager/javapackager.res")
                    args(WIN.fxpackager.rcSource)
                }
            }
            doLast {
                mkdir "$buildDir/javapackager"
                exec({
                    commandLine("$WIN.fxpackager.linker", "/nologo", "/opt:REF", "/incremental:no", "/manifest", "kernel32.lib", "advapi32.lib",
                            "/out:$buildDir/native/javapackager/javapackager.exe",
                            "$buildDir/native/javapackager/javapackager.obj",
                            "$buildDir/native/javapackager/javapackager.res")
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                })
            }
            doLast {
                exec({
                    commandLine("$MC", "-manifest",
                                       "$buildDir/native/javapackager/javapackager.manifest",
                                       "-outputresource:$buildDir/native/javapackager/javapackager.exe")
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                })
                copy {
                    from file("$buildDir/native/javapackager/javapackager.exe")
                    into file("$buildDir/javapackager")
                }
            }
        }
    } else {
        task buildJavaPackager(group: "Build") {
            enabled = COMPILE_FXPACKAGER
            doLast {
                copy {
                    from "src/main/native/javapackager/shell"
                    into "$buildDir/javapackager"
                    fileMode = 0755
                }
            }
        }
    }

    jar.dependsOn buildJavaPackager

    classes << {
        // Copy all of the download libraries to libs directory for the sake of the IDEs
        File libsDir = rootProject.file("build/libs");
        File antLib = new File(libsDir, "ant-1.8.2.jar")
        libsDir.mkdirs();

        // Skip copy if file is present.
        if (antLib.exists()) return;

        for (File f : configurations.compile.files) {
            copy {
                into libsDir
                from f.getParentFile()
                include "**/ant-1.8.2.jar"
                includeEmptyDirs = false
            }
        }
    }

    task packagerFakeJar(type: Jar) {
        dependsOn compileTestJava
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "mainApp.jar"

        manifest {
            attributes(
                    "Main-Class": "hello.HelloRectangle",
                    "Custom-Attribute": " Is it stripped?"
            )
        }

        doFirst {
            copy {
                from "$projectDir/src/main/resources/com/oracle/tools/packager/linux/javalogo_white_48.png"
                from "$projectDir/src/main/resources/com/oracle/tools/packager/mac/GenericAppHiDPI.icns"
                from "$projectDir/src/main/resources/com/oracle/tools/packager/windows/javalogo_white_48.ico"
                from "$projectDir/src/test/resources/hello/java-logo2.gif"
                from "$projectDir/src/test/resources/hello/small.ico"
                from "$projectDir/src/test/resources/hello/test.icns"
                from "$projectDir/src/test/resources/hello/LICENSE-RTF.rtf"
                from "$projectDir/../../LICENSE"
                from "$projectDir/build/libs/packager.jar"
                into project.file("$projectDir/build/tmp/tests/appResources")
            }
            copy {
                from "$projectDir/../../LICENSE"
                into project.file("$projectDir/build/tmp/tests/appResources")
                rename '(.*)LICENSE', '$1LICENSE2'
            }
        }
    }

    task packagerFXPackagedJar(type: Jar) {
        dependsOn packagerFakeJar
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "packagedMainApp.jar"

        manifest {
            attributes(
                "JavaFX-Application-Class": "hello.TestPackager",
            )
        }
    }

    if (!DO_BUILD_SDK_FOR_TEST) {
        def antJavafxJar = new File(TEST_SDK_DIR, "lib/ant-javafx.jar")
        [compileTestJava, test].each {
            it.classpath = files(antJavafxJar) + it.classpath
        }
    }

    test {
        if (IS_JIGSAW_TEST) {
            enabled = false // FIXME: JIGSAW -- support this with modules
            logger.info("JIGSAW Testing disabled for fxpackager")
        }

        dependsOn packagerFXPackagedJar
        systemProperty "RETAIN_PACKAGER_TESTS", RETAIN_PACKAGER_TESTS
        systemProperty "TEST_PACKAGER_DMG", TEST_PACKAGER_DMG
        systemProperty "FULL_TEST", FULL_TEST
        executable = JIGSAW_JAVA;
    }

    def packagerDevOpts = []
    try {
        packagerDevOpts.addAll(PACKAGER_DEV_OPTS.split(' '))
    } catch (MissingPropertyException ignore) {
        packagerDevOpts.addAll("image")
    }

    task packagerDev(dependsOn: [jar, testClasses, packagerFakeJar], type:JavaExec) {
        workingDir = project.file("build/tmp/tests/appResources/")
        executable = JIGSAW_JAVA
        classpath = project.files("build/libs/ant-javafx.jar", "build/classes/test", "build/resources/test")
        main = "hello.SimpleBundle"
        args = [
                '-modulepath', JIGSAW_MODULES,
                '-o', "$projectDir/build/dev",
                '-all',
                packagerDevOpts
        ].flatten()
    }
}

project(":media") {
    configurations {
        media
    }

    project.ext.buildModule = true
    project.ext.moduleRuntime = true
    project.ext.moduleName = "javafx.media"

    dependencies {
        compile BUILD_SRC, project(":base"), project(":graphics")
    }

    sourceSets {
        tools {
            java.srcDir "src/tools/java"
        }
    }

    compileToolsJava {
        enabled = IS_COMPILE_MEDIA
        classpath = sourceSets.main.output;
    }

    project.ext.makeJobsFlag = IS_WINDOWS && IS_DEBUG_NATIVE ? "-j1" : "-j5";
    project.ext.buildType = IS_DEBUG_NATIVE ? "Debug" : "Release";

    def nativeSrcDir = file("${projectDir}/src/main/native")
    def generatedHeadersDir = file("${buildDir}/generated-src/headers")

    task generateHeaders(dependsOn: compileJava) {
        enabled = IS_COMPILE_MEDIA
        doLast {
            def classpath = sourceSets.main.output;
            mkdir generatedHeadersDir;

            def classesList = ["com.sun.media.jfxmedia.logging.Logger",
                             "com.sun.media.jfxmedia.track.AudioTrack",
                             "com.sun.media.jfxmedia.control.VideoDataBuffer",
                             "com.sun.media.jfxmedia.control.VideoFormat\$FormatTypes",
                             "com.sun.media.jfxmediaimpl.NativeAudioClip",
                             "com.sun.media.jfxmediaimpl.NativeMediaPlayer",
                             "com.sun.media.jfxmediaimpl.NativeVideoBuffer",
                             "com.sun.media.jfxmediaimpl.platform.gstreamer.GSTPlatform",
                             "com.sun.media.jfxmediaimpl.platform.gstreamer.GSTMedia",
                             "com.sun.media.jfxmediaimpl.platform.gstreamer.GSTMediaPlayer",
                             "com.sun.media.jfxmediaimpl.NativeAudioEqualizer",
                             "com.sun.media.jfxmediaimpl.NativeEqualizerBand",
                             "com.sun.media.jfxmediaimpl.NativeAudioSpectrum"]
            if (IS_MAC) {
                classesList.addAll( ["com.sun.media.jfxmediaimpl.platform.osx.OSXPlatform",
                                     "com.sun.media.jfxmediaimpl.platform.osx.OSXMedia",
                                     "com.sun.media.jfxmediaimpl.platform.osx.OSXMediaPlayer"] );
            }
            exec {
                commandLine ("${JAVAH}", "-d", "${generatedHeadersDir}", "-classpath", "${classpath.asPath}");
                args classesList;
            }
        }
    }

    task generateMediaErrorHeader(dependsOn: [compileToolsJava, compileJava]) {
        enabled = IS_COMPILE_MEDIA
        doLast {
            def classpath = files(sourceSets.main.output, sourceSets.tools.output);
            def sourcepath = sourceSets.main.java.srcDirs;
            def headerpath = file("$generatedHeadersDir/jfxmedia_errors.h");
            def srcRoot = (sourcepath.toArray())[0];

            mkdir generatedHeadersDir;

            exec {
                commandLine("$JAVA", "-classpath", "${classpath.asPath}");
                args("headergen.HeaderGen", "$headerpath", "$srcRoot");
            }
        }
    }

    task buildNativeTargets {
        enabled = IS_COMPILE_MEDIA
    }

    compileTargets { t->
        def targetProperties = project.rootProject.ext[t.upper]
        def nativeOutputDir = file("${buildDir}/native/${t.name}")
        def projectDir = t.name.startsWith("arm") ? "linux" : t.name
        def mediaProperties = targetProperties.media
        // Makefile for OSX needs to know if we're building for parfait
        def compileParfait = IS_COMPILE_PARFAIT ? "true" : "false"

        def buildNative = task("build${t.capital}Native", dependsOn: [generateHeaders, generateMediaErrorHeader]) {
            enabled = targetProperties.compileMediaNative
            if (!targetProperties.compileMediaNative) {
                println("Not compiling native Media for ${t.name} per configuration request");
            }

            doLast {
                exec {
                    commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/jfxmedia/projects/${projectDir}")
                    args("JAVA_HOME=${JDK_HOME}", "GENERATED_HEADERS_DIR=${generatedHeadersDir}",
                         "OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}", "BASE_NAME=jfxmedia",
                         "COMPILE_PARFAIT=${compileParfait}",
                         IS_64 ? "ARCH=x64" : "ARCH=x32",
                        "CC=${mediaProperties.compiler}", "LINKER=${mediaProperties.linker}")

                    if (t.name == "win") {
                        environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                        args( "RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.jfxmediaRcFile}")
                    } else {
                        if (t.name.startsWith("arm")) {
                            args("EXTRA_CFLAGS=${mediaProperties.extra_cflags}", "EXTRA_LDFLAGS=${mediaProperties.extra_ldflags}")
                        } else {
                            args("HOST_COMPILE=1")
                        }
                    }
                }
            }
        }

        // check for the property disable${name} = true
        def boolean disabled = targetProperties.containsKey('disableMedia') ? targetProperties.get('disableMedia') : false
        if (!disabled) {
            // Building GStreamer
            def buildGStreamer = task("build${t.capital}GStreamer") {
                enabled = IS_COMPILE_MEDIA
                doLast {
                    exec {
                        commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/${projectDir}/gstreamer-lite")
                        args("OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}", "BASE_NAME=gstreamer-lite",
                             IS_64 ? "ARCH=x64" : "ARCH=x32", "CC=${mediaProperties.compiler}",
                             "AR=${mediaProperties.ar}", "LINKER=${mediaProperties.linker}")

                        if (t.name == "win") {
                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                            args("RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.gstreamerRcFile}")
                        }
                    }
                }
            }

            def buildPlugins = task("build${t.capital}Plugins", dependsOn: buildGStreamer) {
                enabled = IS_COMPILE_MEDIA

                if (!project.ext.properties.containsKey("ON2_SRCDIR")) {
                    project.ext.ON2_SRCDIR = "";
                }

                if (!project.ext.properties.containsKey("ON2_LIB")) {
                    project.ext.ON2_LIB = "";
                }

                doLast {
                    exec {
                        commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/${projectDir}/fxplugins")
                        args("OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}", "BASE_NAME=fxplugins",
                             "ON2_SRCDIR=${project.ext.ON2_SRCDIR}", "ON2_LIB=${project.ext.ON2_LIB}",
                             IS_64 ? "ARCH=x64" : "ARCH=x32",
                             "CC=${mediaProperties.compiler}", "AR=${mediaProperties.ar}", "LINKER=${mediaProperties.linker}")

                        if (t.name == "win") {
                            Map winEnv = new HashMap(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)

                            String sdkDir = System.getenv("BASECLASSES_SDK_DIR");
                            if (sdkDir == null) {
                                sdkDir = "C:/Program Files/Microsoft SDKs/Windows/v7.1" // Default value
                                winEnv["BASECLASSES_SDK_DIR"] = sdkDir
                            }
                            environment(winEnv)

                            args("RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.fxpluginsRcFile}")
                        }
                    }
                }
            }

            buildNative.dependsOn buildPlugins

            if (t.name == "linux") {
                def buildAVPlugin = task( "buildAVPlugin", dependsOn: [buildPlugins]) {
                    enabled = IS_COMPILE_MEDIA

                    doLast {
                        if (project.ext.properties.containsKey("libav")) {
                            project.ext.libav.versions.each { version ->
                                def libavDir = "${project.ext.libav.basedir}-${version}"
                                File dir = file(libavDir)
                                if (dir.exists()) {
                                    exec {
                                        commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/linux/avplugin")
                                        args("CC=${mediaProperties.compiler}", "LINKER=${mediaProperties.linker}",
                                             "OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}",
                                             "BASE_NAME=avplugin", "VERSION=${version}", "LIBAV_DIR=${libavDir}",
                                             "SUFFIX=", IS_64 ? "ARCH=x64" : "ARCH=x32")
                                    }
                                }
                            }

                            project.ext.libav.ffmpeg.versions.each { version ->
                                def libavDir = "${project.ext.libav.ffmpeg.basedir}-${version}"
                                File dir = file(libavDir)
                                if (dir.exists()) {
                                    exec {
                                        commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/linux/avplugin")
                                        args("CC=${mediaProperties.compiler}", "LINKER=${mediaProperties.linker}",
                                             "OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}",
                                             "BASE_NAME=avplugin", "VERSION=${version}", "LIBAV_DIR=${libavDir}",
                                             "SUFFIX=-ffmpeg", IS_64 ? "ARCH=x64" : "ARCH=x32")
                                    }
                                }
                            }
                        } else {
                            // Building fxavcodec plugin (libav plugin)
                            exec {
                                commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/linux/avplugin")
                                args("CC=${mediaProperties.compiler}", "LINKER=${mediaProperties.linker}",
                                     "OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}",
                                     "BASE_NAME=avplugin", IS_64 ? "ARCH=x64" : "ARCH=x32")
                            }
                        }
                    }
                }
                buildNative.dependsOn buildAVPlugin
            }

            if (t.name == "win") {
                def buildResources = task("buildResources") << {
                    def rcOutputDir = "${nativeOutputDir}/${buildType}"
                    mkdir rcOutputDir
                    exec {
                        environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                        commandLine (WIN.media.rcCompiler)
                        args(WIN.media.glibRcFlags)
                        args("/Fo${rcOutputDir}/${WIN.media.glibRcFile}", WIN.media.rcSource)
                    }

                    exec {
                        environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                        commandLine (WIN.media.rcCompiler)
                        args(WIN.media.gstreamerRcFlags)
                        args("/Fo${rcOutputDir}/${WIN.media.gstreamerRcFile}", WIN.media.rcSource)
                    }

                    exec {
                        environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                        commandLine (WIN.media.rcCompiler)
                        args(WIN.media.fxpluginsRcFlags)
                        args("/Fo${rcOutputDir}/${WIN.media.fxpluginsRcFile}", WIN.media.rcSource)
                    }

                    exec {
                        environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                        commandLine (WIN.media.rcCompiler)
                        args(WIN.media.jfxmediaRcFlags)
                        args("/Fo${rcOutputDir}/${WIN.media.jfxmediaRcFile}", WIN.media.rcSource)
                    }
                }

                def buildGlib = task("build${t.capital}Glib", dependsOn: [buildResources]) {
                    enabled = IS_COMPILE_MEDIA
                    doLast {
                        exec {
                            environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                            commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite")
                            args("OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}", "BASE_NAME=glib-lite",
                                 IS_64 ? "ARCH=x64" : "ARCH=x32", "RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.glibRcFile}",
                                 "CC=${mediaProperties.compiler}", "AR=${mediaProperties.ar}", "LINKER=${mediaProperties.linker}")
                        }
                    }
                }
                buildGStreamer.dependsOn buildGlib

            } else if (t.name == "mac") {
                def buildGlib = task("build${t.capital}Glib") {
                    enabled = IS_COMPILE_MEDIA
                    doLast {
                        exec {
                            commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/${projectDir}/libffi")
                            args("OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}", "BASE_NAME=ffi")
                            args ("CC=${mediaProperties.compiler}", "LINKER=${mediaProperties.linker}", "AR=${mediaProperties.ar}")
                        }

                        exec {
                            commandLine ("make", "${makeJobsFlag}", "-C", "${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite")
                            args("OUTPUT_DIR=${nativeOutputDir}", "BUILD_TYPE=${buildType}", "BASE_NAME=glib-lite")
                            args ("CC=${mediaProperties.compiler}", "LINKER=${mediaProperties.linker}")
                        }
                    }
                }
                buildGStreamer.dependsOn buildGlib
            }
        }

        buildNativeTargets.dependsOn buildNative
    }

    jar {
        exclude("headergen/**")

        dependsOn compileJava
        if (IS_COMPILE_MEDIA) {
            dependsOn buildNativeTargets
        }
    }
}

project(":web") {
    configurations {
        webkit
    }
    project.ext.buildModule = true
    project.ext.moduleRuntime = true
    project.ext.moduleName = "javafx.web"

    Set<String> testInclude = [ "test/**" ]
    configureJigsawTests(project, [ "base", "graphics" ],
        null, testInclude,
        project.projectDir.path + "/src/test/addExports"
        )

    dependencies {
        compile project(":base"), project(":graphics"), project(":controls"), project(":media")
    }

    test {
        if (!IS_JIGSAW_TEST) {
        //TODO: support this in Jake
        // Run web tests in headless mode
        systemProperty 'glass.platform', 'Monocle'
        systemProperty 'monocle.platform', 'Headless'
        systemProperty 'prism.order', 'sw'
        }
    }

    if (!IS_COMPILE_WEBKIT) {
        // Include wrapper classes that are otherwise generated by native build
        sourceSets.main.java.srcDirs += "src/main/java-wrappers"
    }

    task generateHeaders(dependsOn: compileJava) {
        doLast {
            def classpath = files("$buildDir/classes/main",
                                  project(":graphics").sourceSets.main.output.classesDir)
            def dest = file("$buildDir/generated-src/headers");
            mkdir dest;
            exec {
                commandLine("$JAVAH", "-d", "$dest",
                            "-classpath", "${classpath.asPath}");
                args("java.lang.Character",
                     "java.net.IDN",
                     "com.sun.webkit.ContextMenu",
                     "com.sun.webkit.ContextMenuItem",
                     "com.sun.webkit.CursorManager",
                     "com.sun.webkit.PageCache",
                     "com.sun.webkit.PopupMenu",
                     "com.sun.webkit.SharedBuffer",
                     "com.sun.webkit.WatchdogTimer",
                     "com.sun.webkit.WebPage",
                     "com.sun.webkit.LoadListenerClient",
                     "com.sun.webkit.event.WCFocusEvent",
                     "com.sun.webkit.event.WCKeyEvent",
                     "com.sun.webkit.event.WCMouseEvent",
                     "com.sun.webkit.event.WCMouseWheelEvent",
                     "com.sun.webkit.graphics.GraphicsDecoder",
                     "com.sun.webkit.graphics.RenderMediaControls",
                     "com.sun.webkit.graphics.RenderTheme",
                     "com.sun.webkit.graphics.ScrollBarTheme",
                     "com.sun.webkit.graphics.WCMediaPlayer",
                     "com.sun.webkit.graphics.WCGraphicsManager",
                     "com.sun.webkit.graphics.WCRenderQueue",
                     "com.sun.webkit.graphics.WCPath",
                     "com.sun.webkit.graphics.WCPathIterator",
                     "com.sun.webkit.Timer",
                     "com.sun.webkit.WCFrameView",
                     "com.sun.webkit.WCPasteboard",
                     "com.sun.webkit.WCPluginWidget",
                     "com.sun.webkit.dom.JSObject",
                     "com.sun.webkit.network.SocketStreamHandle",
                     "com.sun.webkit.network.URLLoader",
                     "com.sun.webkit.text.TextBreakIterator",
                     "com.sun.webkit.text.TextNormalizer");
            }
        }
    }

    task compileGenerated()

    compileTargets { t ->
        def targetProperties = project.rootProject.ext[t.upper]
        def classifier = (t.name != "linux" && t.name != "win") ? t.name :
                          IS_64 ? "${t.name}-amd64" : "${t.name}-i586"
        dependencies {
            webkit group: "com.sun.webkit", name: "webview-deps",
                   version: "1.3", classifier: "$classifier", ext: "zip"
        }

        def webkitOutputDir = "$buildDir/${t.name}"
        def webkitConfig = IS_DEBUG_NATIVE ? "Debug" : "Release"

        def compileNativeTask = task("compileNative${t.capital}", dependsOn: generateHeaders) << {
            println "Building Webkit configuration /$webkitConfig/ into $webkitOutputDir"

            def dependencyFile = configurations.webkit.filter(
                    { File f -> f.getName().contains(classifier) }
                ).getSingleFile()
            ant.unzip(src:  dependencyFile,
                      dest: webkitOutputDir)

            exec {
                workingDir("$projectDir/src/main/native")
                commandLine("perl", "Tools/Scripts/set-webkit-configuration", "--$webkitConfig")
                environment(["WEBKIT_OUTPUTDIR" : webkitOutputDir])
            }

            exec {
                workingDir("$projectDir/src/main/native")
                if (t.name == "win") {
                    String qtDir = cygpath(System.getenv().get("QTSDK_DIR"))
                    String parfaitPath = IS_COMPILE_PARFAIT ? System.getenv().get("PARFAIT_PATH") + ";" : "";
                    Map environmentSettings = new HashMap(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                    environmentSettings["PATH"] = parfaitPath + "$WINDOWS_VS_PATH;$qtDir/bin;$qtDir/qt/bin"
                    environmentSettings["QMAKESPEC"] = "win32-msvc2013"
                    environment(environmentSettings)
                    /* To build with ICU:
                    1. Download http://javaweb.us.oracle.com/jcg/fx-webrevs/RT-17164/WebKitLibrariesICU.zip
                    and unzip it to WebKitLibraries folder.
                    2. Copy DLLs from
                    WebKitLibrariesICU.zip\WebKitLibraries\import\runtime
                    to %windir%\system32
                    3. Uncomment the line below
                     */
                    // args("--icu-unicode")
                } else if (t.name == "mac") {
                    environment([
                        "QMAKESPEC"      : "macx-clang",
                        "QMAKE_CFLAGS"   : "-m64",
                        "QMAKE_LFLAGS"   : "-m64",
                    ])
                } else if (t.name == "linux") {
                    if (IS_64) {
                        environment([
                            "QMAKESPEC"      : "linux-g++-64",
                        ])
                    } else {
                        environment([
                            "QMAKESPEC"      : "linux-g++-32",
                            "QMAKE_CFLAGS"   : "-m32",
                            "QMAKE_LFLAGS"   : "-m32",
                        ])
                    }
                } else if (t.name.startsWith("arm")) {
                    // ARM cross build
                    def webkitProperties = project.rootProject.ext[t.upper].webkit
                    def qmakeSpecDir = "$webkitOutputDir/qws/linux-cross-${t.name}-g++"
                    mkdir qmakeSpecDir
                    File qmakeSpec = new File("$qmakeSpecDir/qmake.conf")
                    qmakeSpec.append(
"""TARGET_PLATFORM         = unix
include(/usr/share/qt4/mkspecs/common/linux.conf)
include(/usr/share/qt4/mkspecs/common/g++.conf)
include(/usr/share/qt4/mkspecs/common/qws.conf)
QMAKE_CC                = $webkitProperties.compiler
QMAKE_CXX               = $webkitProperties.linker
QMAKE_LINK              = $webkitProperties.linker
QMAKE_LINK_SHLIB        = $webkitProperties.linker
QMAKE_AR                = $webkitProperties.ar cqs
QMAKE_OBJCOPY           = $webkitProperties.objcopy
QMAKE_STRIP             = $webkitProperties.strip
QMAKE_CXXFLAGS          = $webkitProperties.ccFlags
QMAKE_LFLAGS            = $webkitProperties.linkFlags
load(qt_config)""")
                    environment([
                        "QMAKESPEC" : file(qmakeSpecDir).getAbsolutePath(),
                        "PATH"      : "$System.env.PATH:$webkitProperties.binDir",
                    ])
                    args("--nocache")
                }
                environment([
                    "JAVA_HOME"       : JDK_HOME,
                    "WEBKIT_OUTPUTDIR" : webkitOutputDir,
                ])

                if (IS_COMPILE_PARFAIT) {
                    environment([
                        "COMPILE_PARFAIT" : "true",
                        "QMAKE_CC"        : "parfait-gcc",
                        "QMAKE_CXX"       : "parfait-g++",
                        "QMAKE_LINK"      : "parfait-g++",
                    ])
                }
                commandLine("perl", "Tools/Scripts/build-webkit", "--java", "--imageio", "--icu-unicode")
            }

            def library = rootProject.ext[t.upper].library
            copy {
                from "$webkitOutputDir/$webkitConfig/lib/${library('jfxwebkit')}"
                into "$buildDir/libs/${t.name}"
            }
            copy {
                from "$webkitOutputDir/$webkitConfig/lib/${library('DumpRenderTreeJava')}"
                into "$buildDir/test/${t.name}"
            }
        }

        if (IS_WINDOWS && t.name == "win") {
            def webkitProperties = project.rootProject.ext[t.upper].webkit
            def rcTask = project.task("rc${t.capital}", type: CompileResourceTask) {
                compiler = webkitProperties.rcCompiler
                source(webkitProperties.rcSource)
                if (webkitProperties.rcFlags) {
                    rcParams.addAll(webkitProperties.rcFlags)
                }
                output(file("$webkitOutputDir/$webkitConfig/WebCore/obj"))
            }
            compileNativeTask.dependsOn rcTask
        }

        def compileGeneratedTask = task("compileGenerated${t.capital}", type: JavaCompile, dependsOn: compileNativeTask) {
            def gensrcDir = "$webkitOutputDir/$webkitConfig/WebCore/generated/java"
            doFirst {
                copy {
                    from "$projectDir/src/main/java-wrappers/com/sun/webkit/dom/EventListenerImpl.java"
                    into "$gensrcDir/com/sun/webkit/dom"
                }
            }
            classpath = files(project.sourceSets.main.output.classesDir)
            source gensrcDir
            destinationDir = file("$buildDir/classes/main")
        }

        compileGenerated.dependsOn compileGeneratedTask

        if (!targetProperties.compileWebnodeNative) {
            println("Not compiling native Webkit for ${t.name} per configuration request");
            compileNativeTask.enabled = false
        }
    }

    def drtClasses = "com/sun/javafx/webkit/drt/**"
    jar.exclude(drtClasses)
    task drtJar(type: Jar, dependsOn: compileJava) {
        archiveName = "drt.jar"
        destinationDir = file("$buildDir/test")
        from "$buildDir/classes/main"
        include drtClasses
    }

    if (IS_COMPILE_WEBKIT) {
        jar.dependsOn compileGenerated, drtJar
    }
}

// This project is for system tests that need to run with a full SDK.
// Most of them display a stage or do other things that preclude running
// them in a shared JVM or as part of the "smoke test" run (which must
// not pop up any windows or use audio). As such, they are only enabled
// when FULL_TEST is specified, and each test runs in its own JVM
project(":systemTests") {

    dependencies {
        testCompile project(":graphics").sourceSets.test.output
        testCompile project(":base").sourceSets.test.output
        testCompile project(":controls").sourceSets.test.output
        testCompile project(":swing").sourceSets.test.output
    }

    Set<String> testInclude = [ "test/**" ]
    configureJigsawTests(project, [ "base", "graphics", "controls", "swing", "fxml", "web" ],
        null, testInclude,
        project.projectDir.path + "/src/test/addExports"
    )

    test {
        enabled = IS_FULL_TEST
        if (!IS_USE_ROBOT) {
            // Disable all robot-based visual tests
            exclude("test/robot/**");
        }
        if (!IS_AWT_TEST) {
            // Disable all AWT-based tests
            exclude("**/javafx/embed/swing/*.*");
            exclude("**/com/sun/javafx/application/Swing*.*");
        }

        forkEvery = 1
    }
}

allprojects {
    // The following block is a workaround for the fact that presently Gradle
    // can't set the -XDignore.symbol.file flag, because it appears that the
    // javac API is lacking support for it. So what we'll do is find any Compile
    // task and manually provide the options necessary to fire up the
    // compiler with the right settings.
    //
    // Also, we need to remove jfxrt.jar from the ext classpath (if it is there)
    tasks.withType(JavaCompile) { compile ->
        if (compile.options.hasProperty("useAnt")) {
            compile.options.useAnt = true
            compile.options.useDepend = IS_USE_DEPEND
        } else if (compile.options.hasProperty("incremental")) {
            compile.options.incremental = IS_INCREMENTAL
        }
        compile.options.debug = true // we always generate debugging info in the class files
        compile.options.debugOptions.debugLevel = IS_DEBUG_JAVA ? "source,lines,vars" : "source,lines"
        compile.options.fork = true
        compile.options.forkOptions.executable = JAVAC
        compile.options.warnings = IS_LINT
        compile.options.compilerArgs = ["-XDignore.symbol.file", "-encoding", "UTF-8"]
        if (!DO_BUILD_SDK_FOR_TEST) {
            compile.classpath = files(jfxrtJarFromSdk) + compile.classpath
        }

        // Add in the -Xlint options
        if (IS_LINT) {
            LINT.split("[, ]").each { s ->
                compile.options.compilerArgs += "-Xlint:$s"
            }
        }
    }

    // Some tasks should be disabled not to compile SDK, when running only the tests
    disabledTasks.each {
        project.getTasksByName(it, false)*.enabled = false
    }
}

// fxpackager requires JDK 9 to compile
project(":fxpackager") {
    tasks.withType(JavaCompile) { compile ->
        compile.options.forkOptions.executable = JIGSAW_JAVAC
        compile.options.compilerArgs = [
                "-XaddExports:java.base/sun.security.pkcs=ALL-UNNAMED,"
                        + "java.base/sun.security.timestamp=ALL-UNNAMED,"
                        + "java.base/sun.security.x509=ALL-UNNAMED,"
                        + "jdk.jdeps/com.sun.tools.jdeps=ALL-UNNAMED",
                "-encoding", "UTF-8"]
    }
}

/******************************************************************************
 *                                                                            *
 *                             Top Level Tasks                                *
 *                                                                            *
 *  These are the tasks which are defined only for the top level project and  *
 *  not for any sub projects. These are generally the entry point that is     *
 *  used by Hudson and by the continuous build system.                        *
 *                                                                            *
 *****************************************************************************/

task clean() {
    group = "Basic"
    description = "Deletes the build directory and the build directory of all sub projects"
    getSubprojects().each { subProject ->
        dependsOn(subProject.getTasksByName("clean", true));
    }
    doLast {
        delete(buildDir);
    }
}

task cleanAll() {
    group = "Basic"
    description = "Scrubs the repo of build artifacts"
    dependsOn(clean)
    doLast {
        //delete(".gradle"); This causes problems on windows.
        delete("buildSrc/build");
    }
}

task javadoc(type: Javadoc) {
    enabled = IS_BUILD_JAVADOC
    group = "Basic"
    description = "Generates the JavaDoc for all the public API"
    executable = JAVADOC
    def projectsToDocument = [
            project(":base"), project(":graphics"), project(":controls"), project(":media"),
            project(":swing"), /*project(":swt"),*/ project(":fxml"), project(":web")]
    source(projectsToDocument.collect({
        [it.sourceSets.main.java]
    }));
    setDestinationDir(new File(buildDir, 'javadoc'));
    // FIXME: The following is a workaround for JDK-8151191; it should be
    // reverted once that bug is fixed
    classpath = rootProject.BUILD_SRC
    classpath += files(projectsToDocument.collect { project ->
        project.sourceSets.main.java.srcDirs
    });
    /*
    // Might need a classpath
    classpath = files(projectsToDocument.collect { project ->
        project.sourceSets.main.compileClasspath
    });
    classpath += files(projectsToDocument.collect { project ->
        project.sourceSets.main.output
    });
    */
    exclude("com/**/*", "Compile*", "javafx/builder/**/*", "javafx/scene/accessibility/**/*");
    options.windowTitle("${javadocTitle}")
    options.header("${javadocHeader}")
    options.bottom("${javadocBottom}")
    if (BUILD_CLOSED) {
        options.linksOffline(JDK_DOCS, JDK_DOCS_CLOSED);
    } else {
        options.links(JDK_DOCS);
    }
    options.addBooleanOption("XDignore.symbol.file").setValue(true);
    options.addBooleanOption("Xdoclint:none").setValue(!IS_DOC_LINT);
    options.addBooleanOption("javafx").setValue(true);
    options.addBooleanOption("use").setValue(true);
    doLast {
        projectsToDocument.each { p ->
            copy {
                from "$p.projectDir/src/main/docs"
                into "$buildDir/javadoc"
            }
        }
    }

    dependsOn(projectsToDocument.collect { project -> project.getTasksByName("classes", true)});
}

task jfxrt() {
    if (DO_BUILD_SDK_FOR_TEST) {
        rootProject.getTasksByName("compileTestJava", true).each { t ->
            if (t.enabled) t.dependsOn(jfxrt)
        }
    }
}

task sdk() {
    dependsOn(checkJfxrtJar)

    if (DO_BUILD_SDK_FOR_TEST) {
        rootProject.getTasksByName("test", true).each { t ->
            if (t.enabled) t.dependsOn(sdk)
        }
    }
}

task appsjar() {
    dependsOn(sdk)
    // Note: the jar dependencies get added elsewhere see project(":apps")
}

// these are empty tasks, allowing us to depend on the task, which may have other
// real work items added later.
task copyAppsArtifacts() {
    dependsOn(appsjar)
}

task apps() {
    dependsOn(sdk)
    dependsOn(appsjar)
    dependsOn(copyAppsArtifacts)
}

task findbugs() {
    dependsOn(sdk)

    doLast {
        if (!BUILD_CLOSED) {
            println "findbugs task is only run for a closed build"
        }
    }
}

// The following tasks are for the closed build only. They are a no-op for the open build

task checkCache() {
    dependsOn(updateCacheIfNeeded)
}

// TODO: consider moving the "public-sdk" portion of this task here
task publicExports() {
    doFirst {
        if (BUILD_CLOSED && !IS_BUILD_JAVADOC) {
            fail("publicExports task requires: -PBUILD_JAVADOC=true")
        }
    }
    dependsOn(sdk)
}

task perf() {
    dependsOn(sdk,apps)
    doLast {
        if (!BUILD_CLOSED) {
            println "perf task is only run for a closed build"
        }
    }
}

task zips() {
    doFirst {
        if (BUILD_CLOSED && !IS_BUILD_JAVADOC) {
            fail("zips task requires: -PBUILD_JAVADOC=true")
        }
    }
    dependsOn(sdk,publicExports,apps,perf)
}

task copySources(type: Copy) {
    enabled = IS_BUILD_SRC_ZIP
    def projectsToCopy = [
            project(":base"), project(":graphics"), project(":controls"),
            project(":swing"), project(":swt"), project(":fxml"),
            project(":media"), project(":web")]
    from(projectsToCopy.collect({ proj ->
        files(proj.sourceSets.main.java.srcDirs)
    }))
    include "**/*.java"
    into "${buildDir}/javafx-src"
}

task zipSources(type: Zip) {
    enabled = IS_BUILD_SRC_ZIP
    dependsOn(copySources)
    archiveName = "javafx-src.zip"
    destinationDir = file("$buildDir")
    includeEmptyDirs = false
    from "${buildDir}/javafx-src"
}

task src {
    enabled = IS_BUILD_SRC_ZIP
    description = "Created the javafx-src.zip bundle"
    dependsOn(zipSources)
}

task all() {
    dependsOn(sdk,publicExports,apps,perf,zips)
}


// Construct list of subprojects that are modules
ext.moduleProjList = []
subprojects {
    if (project.hasProperty("buildModule") && project.ext.buildModule) {
        rootProject.ext.moduleProjList += project
        println "module: $project (buildModule=YES)"
    } else {
        println "module: $project (buildModule=NO)"
    }
}


// Create the legacy sdk from the modular-sdk

compileTargets { t ->
    def targetProperties = project.ext[t.upper]
    def platformPrefix = targetProperties.platformPrefix
    def sdkDirName = "${platformPrefix}sdk"
    def modularSdkDirName = "${platformPrefix}modular-sdk"
    def modularSdkDir = "${rootProject.buildDir}/${modularSdkDirName}"
    def modulesDir = "${modularSdkDir}/modules"
    def modulesCmdsDir = "${modularSdkDir}/modules_cmds"
    def modulesLibsDir = "${modularSdkDir}/modules_libs"

    // The jfxrt task is responsible for creating the legacy jfxrt.jar. A developer may
    // have multiple SDK's on their system at any one time, depending on which
    // cross compiles they have done. For example, I might have:
    //      build/ios-sdk/lib/jfxrt.jar
    //      build/armhf-sdk/lib/jfxrt.jar
    // and so forth. The default host build will always install into 'sdk'
    // allowing for uses where a known sdk path is needed (like IDEs)
    //      build/sdk/lib/jfxrt.jar
    // This arrangement allows for multiple independent SDKs to
    // exist on a developer's system.
    def jfxrtTask = task("jfxrt$t.capital", type: Jar) {
        group = "Basic"
        description = "Creates the jfxrt.jar for the $t.name target"
        archiveName = "build/${sdkDirName}/lib/jfxrt.jar";
        includeEmptyDirs = false

        moduleProjList.each { project ->
            if (project.ext.moduleRuntime) {
                from("${modulesDir}/${project.ext.moduleName}");
            }
        }

        dependsOn(subprojects.collect { project -> project.getTasksByName("assemble", true)});
    }

    def jfxrtIndexTask = task("jfxrtIndex$t.capital") {
        //the following is a workaround for the lack of indexing in gradle 1.4 through 1.7
        dependsOn(jfxrtTask)

        doLast() {
            ant.jar (update: true, index: true, destfile: jfxrtTask.archiveName)
        }
    }
    jfxrt.dependsOn(jfxrtIndexTask)

    // FIXME: JIGSAW -- update this for modules
    def jfxswtTask = task("jfxswt$t.capital", type: Jar) {
        enabled = COMPILE_SWT
        group = "Basic"
        description = "Creates the jfxswt.jar for the $t.name target"
        archiveName = "build/${sdkDirName}/lib/jfxswt.jar";
        includeEmptyDirs = false
        from("modules/swt/build/classes/main");
        include("**/javafx/embed/swt/**")
        exclude("**/*.java");  // Builder java files are in build/classes and should be excluded

        dependsOn(subprojects.collect { project -> project.getTasksByName("assemble", true)});
    }

    def jfxswtIndexTask = task("jfxswtIndex$t.capital") {
        //the following is a workaround for the lack of indexing in gradle 1.4 through 1.7
        dependsOn(jfxswtTask)

        doLast() {
            ant.jar (update: true, index: true, destfile: jfxswtTask.archiveName)
        }
    }
    jfxrt.dependsOn(jfxswtIndexTask)

    def jmxTask = task ("jmx${t.capital}", type: Jar) {
        group = "Basic"
        description = "Creates the javafx-mx.jar"
        archiveName = "build/${sdkDirName}/lib/javafx-mx.jar";
        includeEmptyDirs = false
        from "modules/jmx/build/classes/main"
        from "modules/jmx/build/resources/main"
        dependsOn project(":jmx").assemble
    }

    // The 'sdk' task will build the rest of the legacy SDK, and depends
    // on the 'jfxrtTask' task. After executing this task the sdk bundle for
    // the current COMPILE_TARGETS will be fully created.
    def sdkTask = task("sdk$t.capital") {
        group = "Basic"
        description = "Creates the SDK for $t.name"
        doLast {
            copy {
                moduleProjList.each { project ->
                    from "${modulesLibsDir}/${project.ext.moduleName}"
                }
                into "build/${sdkDirName}/lib"
            }

            copy {
                moduleProjList.each { project ->
                    from "${modulesCmdsDir}/${project.ext.moduleName}"
                }
                into "build/${sdkDirName}/bin"
            }

            // FIXME: JIGSAW -- update this for modules
            // Copy over the javadocs that were generated. This is done rather than just generating
            // the docs into the "right place" because for a cross-compile you only need one set of
            // docs but need to have a copy in each created sdk
            if (IS_BUILD_JAVADOC) {
                copy {
                    from "build/javadoc"
                    into "build/${sdkDirName}/docs/api"
                }
            }

            // FIXME: JIGSAW -- update this for modules
            // Copy over the javafx-src bundle
            if (IS_BUILD_SRC_ZIP) {
                copy {
                    from "build/javafx-src.zip"
                    into "build/${sdkDirName}"
                }
            }

            // FIXME: JIGSAW -- update this for modules
            // Copy over the javapackager man files
            copy {
                from "modules/fxpackager/build/man"
                into "build/${sdkDirName}/man"
            }
        }
        dependsOn(jmxTask);
        dependsOn(jfxrtIndexTask)
        dependsOn(jfxswtIndexTask)
        dependsOn(javadoc)
        dependsOn(src)
    }

    def generateSymbols = targetProperties.containsKey('generateSymbols') ? targetProperties.generateSymbols : false
    if (generateSymbols) {
        def exportedSymbolsTask = project.task("exportedSymbols${t.capital}", type: ExportedSymbolsTask, dependsOn: sdkTask, group: "Build") {
            description = "Generates exported symbols file for iOS build (from .a libraries)"
            def libDirName = "build/${sdkDirName}/$targetProperties.libDest"
            libDir = file("$libDirName")
            outputFile = file("$libDirName/exported.symbols")
            excludes = targetProperties.generateSymbolsExcludes
        }
        sdk.dependsOn(exportedSymbolsTask)
    }

    sdk.dependsOn(sdkTask)
}

/*
 * This clause changes the way we handle a build.gradle within ./apps
 * It does a few things:
 *   modifies the classpath used to include the built runttime classes
 *   provides for copying the build applications to the artifacts tree
 *
 * The applications to be built will be under ./apps, but also must
 * be listed in the applications listed in the setting variable: JFXApplications
 */
ext.JFXRT_CP =
    files(
        project(":base").sourceSets.main.output.classesDir,
        project(":graphics").sourceSets.main.output.classesDir,
        project(":controls").sourceSets.main.output.classesDir,
        project(":fxml").sourceSets.main.output.classesDir,
        project(":swing").sourceSets.main.output.classesDir, //NOTE - used by 3Dviewer
            "modules/media/build/classes/main",
            "modules/web/build/classes/main",
    )

project(":apps") {
    // The apps build is Ant based, and gradle lets us "import" ant build.xml
    // into our configuration.

    ant.importBuild 'build.xml'

    compileTargets { t ->
        // The apps build is Ant based, and gradle lets us "import" ant apps/build.xml
        // into our configuration.

        // override the apps build.xml with an explicit pointer to our jar.
        def platformPrefix = rootProject.ext[t.upper].platformPrefix
        def sdkDirName = "${platformPrefix}sdk"
        def jfxrtJar = "${rootProject.buildDir}/${sdkDirName}/lib/jfxrt.jar"

        def appsJar = project.task("appsJar${t.capital}") {
            dependsOn(sdk)
            doLast() {
              ant.properties['targetBld'] = "$t.name"
              if (!rootProject.ext[t.upper].compileSwing) {
                ant.properties['JFX_CORE_ONLY'] = 'true'
              }
              ant.properties['jfxbuild.jfxrt.jar'] = jfxrtJar
              ant.properties['platforms.JDK_1.8.home'] = "${rootProject.ext.JDK_HOME}"
              ant.project.executeTarget("sampleAppsJar")
              ant.project.executeTarget("scenebuilderSampleAppsJar")
              if (!t.name.startsWith("arm")) {
                ant.project.executeTarget("scenebuilderAppJar")
              }
            }
        }
        rootProject.appsjar.dependsOn(appsJar)

        def appsClean = project.task("appsClean${t.capital}") {
            doLast() {
              ant.properties['targetBld'] = "$t.name"
              ant.properties['platforms.JDK_1.8.home'] = "${rootProject.ext.JDK_HOME}"
              ant.project.executeTarget("sampleAppsClean")
              ant.project.executeTarget("scenebuilderSampleAppsClean")
              if (!t.name.startsWith("arm")) {
                ant.project.executeTarget("scenebuilderAppClean")
              }
            }
        }
        rootProject.clean.dependsOn(appsClean)
    }
}


/******************************************************************************
 *                                                                            *
 *                               Modules                                      *
 *                                                                            *
 *****************************************************************************/

ext.moduleDependencies = [file("dependencies")]

task buildModules {
}

// Combine the classes, lib, and bin for each module
compileTargets { t ->
    def targetProperties = project.ext[t.upper]

    def platformPrefix = targetProperties.platformPrefix
    def modularSdkDirName = "${platformPrefix}modular-sdk"
    def modularSdkDir = "${rootProject.buildDir}/${modularSdkDirName}"
    def modulesDir = "${modularSdkDir}/modules"
    def modulesCmdsDir = "${modularSdkDir}/modules_cmds"
    def modulesLibsDir = "${modularSdkDir}/modules_libs"
    def modulesSrcDir = "${modularSdkDir}/modules_src"
    def modulesConfDir = "${modularSdkDir}/modules_conf"
    def modulesMakeDir = "${modularSdkDir}/make"

    def zipTask = project.task("buildModuleZip$t.capital", type: Zip, group: "Build") {
        // FIXME: JIGSAW -- this should be moved to a sub-directory so we can keep the same name
        def jfxBundle = "${platformPrefix}javafx-exports.zip"

        doFirst() {
            file("${rootProject.buildDir}/${jfxBundle}").delete()
        }

        archiveName = jfxBundle
        destinationDir = file("${rootProject.buildDir}")
        includeEmptyDirs = false
        from "${modularSdkDir}"
    }
    buildModules.dependsOn(zipTask)

    def buildModulesTask = task("buildModules$t.capital", group: "Build") {
        doLast {
            moduleProjList.each { project ->

                // Copy classes, bin, and lib directories

                def moduleName = project.ext.moduleName
                def buildDir = project.buildDir

                def srcClassesDir = "${buildDir}/${platformPrefix}module-classes"
                def dstClassesDir = "${modulesDir}/${moduleName}"
                copy {
                    from srcClassesDir
                    into dstClassesDir
                }

                def srcCmdsDir = "${buildDir}/${platformPrefix}module-bin"
                def dstCmdsDir = "${modulesCmdsDir}/${moduleName}"
                copy {
                    from srcCmdsDir
                    into dstCmdsDir
                }

                def srcLibsDir = "${buildDir}/${platformPrefix}module-lib"
                def dstLibsDir = "${modulesLibsDir}/${moduleName}"
                copy {
                    from srcLibsDir
                    into dstLibsDir
                }

                // Copy module-info.java
                def srcModuleInfoDir = "${project.projectDir}/src/main/module-info"
                def dstModuleInfoDir = "${modulesSrcDir}/${moduleName}"
                copy {
                    from srcModuleInfoDir
                    into dstModuleInfoDir
                    if (!IS_COMPILE_JFR && project.name.equals("base")) {
                        filter { line-> line.contains("requires jdk.jfr;") ? "" : line }
                    }
                }

                // Copy make/build.properties
                def srcMakeDir = "${project.projectDir}/make"
                def dstMakeDir = "${modulesMakeDir}/${moduleName}"
                copy {
                    from srcMakeDir
                    into dstMakeDir
                }
            }

            // Copy dependencies/*/module-info.java.extra
            def dependencyRoots = moduleDependencies
            if (rootProject.hasProperty("closedModuleDepedencies")) {
                dependencyRoots = [dependencyRoots, closedModuleDepedencies].flatten()
            }
            copy {
                dependencyRoots.each { root ->
                    from root
                }
                into modulesSrcDir
            }

            // concatecate java.policy files into a single file
            //
            def outputPolicyDir = "${modulesConfDir}/java.base/security"
            def outputPolicyFile = file("${outputPolicyDir}/java.policy.extra")
            mkdir outputPolicyDir
            outputPolicyFile.delete()
            moduleProjList.each { project ->
                def policyDir = "${project.projectDir}/src/main/conf/security"
                def policyFile = file("${policyDir}/java.policy")
                if (policyFile.exists()) outputPolicyFile << policyFile.text
            }
        }
    }
    zipTask.dependsOn(buildModulesTask);
    buildModules.dependsOn(buildModulesTask)

    def isWindows = IS_WINDOWS && t.name == "win";
    def isMac = IS_MAC && t.name == "mac";

    // Create layout for modular classes
    moduleProjList.each { project ->
        def buildModuleClassesTask = project.task("buildModule$t.capital", group: "Build") {
            dependsOn(project.assemble)
            def buildDir = project.buildDir
            def sourceBuildDirs = [
                "${buildDir}/classes/main",
                "${buildDir}/resources/main"
            ]
            if (project.hasProperty("extraBuildDirs")) {
                sourceBuildDirs += project.ext.extraBuildDirs
            }
            doLast {
                def moduleClassesDir = "$buildDir/${platformPrefix}module-classes"
                copy {
                    includeEmptyDirs = false
                    sourceBuildDirs.each { d ->
                        from d
                    }
                    into moduleClassesDir

                    // Exclude obsolete, experimental, or non-shipping code
                    exclude("version.rc")
                    exclude("com/sun/glass/ui/swt")
                    exclude("com/sun/javafx/tools/ant")
                    exclude("com/javafx/main")
                    if (!IS_INCLUDE_NULL3D) {
                        exclude ("com/sun/prism/null3d")
                    }
                    if (!IS_INCLUDE_ES2) {
                           exclude("com/sun/prism/es2",
                                   "com/sun/scenario/effect/impl/es2")
                    }

                    // Exclude platform-specific classes for other platforms

                    if (!isMac) {
                        exclude ("com/sun/media/jfxmediaimpl/platform/osx",
                                 "com/sun/prism/es2/MacGL*",
                                 "com/sun/glass/events/mac",
                                 "com/sun/glass/ui/mac",
                                 )
                    }

                    if (!isWindows) {
                        exclude ("**/*.hlsl",
                                 "com/sun/glass/ui/win",
                                 "com/sun/prism/d3d",
                                 "com/sun/prism/es2/WinGL*",
                                 "com/sun/scenario/effect/impl/hw/d3d"
                                 )
                    }

                    if (!targetProperties.includeGTK) { //usually IS_LINUX
                        exclude (
                                 "com/sun/glass/ui/gtk",
                                 "com/sun/prism/es2/EGL*",
                                 "com/sun/prism/es2/X11GL*"
                                 )
                    }

                    if (!targetProperties.includeEGL) {
                        exclude ("com/sun/prism/es2/EGL*")
                    }

                    if (!targetProperties.includeLens) {
                        exclude ("com/sun/glass/ui/lens")
                    }

                    // FIXME: JIGSAW -- Figure out what to do with Monocle
                    /*
                    if (!targetProperties.includeMonocle) {
                        exclude ("com/sun/glass/ui/monocle")
                        exclude("com/sun/prism/es2/Monocle*")
                    }
                    */

                    if (t.name != 'ios') {
                        exclude ("com/sun/media/jfxmediaimpl/platform/ios",
                                 "com/sun/glass/ui/ios",
                                 "com/sun/prism/es2/IOS*"
                                 )
                    }

                    if (t.name != 'android' && t.name != 'dalvik') {
                        exclude ("com/sun/glass/ui/android")
                    }

                    // Filter out other platform-specific classes
                    if (targetProperties.containsKey('jfxrtJarExcludes')) {
                        exclude(targetProperties.jfxrtJarExcludes)
                    }

                    /* FIXME: JIGSAW -- handle this in the module itself
                    if (t.name == 'android') {
                        from ("modules/web/build/classes/android",
                              "modules/web/build/resources/android",
                              "modules/controls/build/classes/android",
                              "modules/controls/build/resources/android")
                    } else if (t.name == 'ios') {
                        from ("modules/web/build/classes/ios",
                              "modules/web/build/resources/ios",
                              "modules/extensions/build/classes/ios")
                    } else {
                        from ("modules/web/build/classes/main", "modules/web/build/resources/main")
                    }
                    */
                }
            }
        }
        buildModulesTask.dependsOn(buildModuleClassesTask)
    }


    def buildModuleLibsTask = task("buildModuleLibs$t.capital") {
        group = "Basic"

        def graphicsProject = project(":graphics");
        dependsOn(graphicsProject.assemble)

        def mediaProject = project(":media");
        dependsOn(mediaProject.assemble)

        def webProject = project(":web");
        dependsOn(webProject.assemble)

        def packagerProject = project(":fxpackager");
        //dependsOn(packagerProject.assemble)
        dependsOn(packagerProject.jar)
        dependsOn(project(":fxpackagerservices").jar)

        doLast {

            def library = targetProperties.library

            // javafx.base (lib/javafx.properties)

            def baseProject = project(":base");
            def moduleLibDir = "${baseProject.buildDir}/${platformPrefix}module-lib"
            mkdir moduleLibDir
            final File javafxProperties = file("${moduleLibDir}/javafx.properties")
            javafxProperties.delete()
            javafxProperties << "javafx.version=$RELEASE_VERSION_SHORT";
            javafxProperties << "\n"
            javafxProperties << "javafx.runtime.version=$RELEASE_VERSION_LONG";
            javafxProperties << "\n"
            javafxProperties << "javafx.runtime.build=$PROMOTED_BUILD_NUMBER";
            javafxProperties << "\n"
            // Include any properties that have been defined (most likely in
            // one of the various platform gradle files)
            if (targetProperties.containsKey("javafxProperties")) {
                javafxProperties << targetProperties.javafxProperties
                javafxProperties << "\n"
            }

            // Embedded builds define this file as well
            if (targetProperties.containsKey("javafxPlatformProperties")) {
                final File javafxPlatformProperties = file("${moduleLibDir}/javafx.platform.properties")
                javafxPlatformProperties.delete()
                javafxPlatformProperties << targetProperties.javafxPlatformProperties
                javafxPlatformProperties << "\n"
            }


            def useLipo = targetProperties.containsKey('useLipo') ? targetProperties.useLipo : false
            def libDest = targetProperties.libDest
            def moduleNativeDirName = "${platformPrefix}module-$libDest"

            // javafx.graphics native libraries

            copy {
                into "${graphicsProject.buildDir}/${moduleNativeDirName}"

                from("modules/graphics/build/libs/jsl-decora/${t.name}/${library(targetProperties.decora.lib)}")
                def libs = ['font', 'prism', 'prismSW', 'glass', 'iio']
                if (IS_INCLUDE_ES2) {
                    libs += ['prismES2'];
                }
                if (IS_COMPILE_PANGO) {
                    libs += ['fontFreetype', 'fontPango'];
                }
                libs.each { lib ->
                    def variants = targetProperties[lib].containsKey('variants') && !useLipo ? targetProperties[lib].variants : [null]
                    variants.each { variant ->
                        def variantProperties = variant ? targetProperties[lib][variant] : targetProperties[lib]
                        from ("modules/graphics/build/libs/$lib/$t.name/${library(variantProperties.lib)}")
                    }
                }
                if (IS_WINDOWS) {
                    from ("modules/graphics/build/libs/prismD3D/${t.name}/${library(targetProperties.prismD3D.lib)}");
                }
            }


            // javafx.media native libraries

            copy {
                into "${mediaProject.buildDir}/${moduleNativeDirName}"

                def mediaBuildType = project(":media").ext.buildType
                if (IS_COMPILE_MEDIA) {
                    [ "fxplugins", "gstreamer-lite", "jfxmedia" ].each { name ->
                        from ("modules/media/build/native/${t.name}/${mediaBuildType}/${library(name)}") }

                    if (t.name == "mac") {
                        // OSX media natives
                        [ "jfxmedia_qtkit", "jfxmedia_avf", "glib-lite" ].each { name ->
                            from ("modules/media/build/native/${t.name}/${mediaBuildType}/${library(name)}") }
                    } else if (t.name == "linux") {
                        from("modules/media/build/native/${t.name}/${mediaBuildType}") { include "libavplugin*.so" }
                    } else from ("modules/media/build/native/${t.name}/${mediaBuildType}/${library("glib-lite")}")
                } else {
                    if (t.name != "android"  && t.name != "dalvik" ) {
                        [ "fxplugins", "gstreamer-lite", "jfxmedia" ].each { name ->
                            from ("$LIBRARY_STUB/${library(name)}") }
                    }

                    if (t.name == "mac") {
                        // copy libjfxmedia_{avf,qtkit}.dylib if they exist
                        [ "jfxmedia_qtkit", "jfxmedia_avf", "glib-lite" ].each { name ->
                            from ("$LIBRARY_STUB/${library(name)}") }
                    } else if (t.name == "linux") {
                        from(LIBRARY_STUB) { include "libavplugin*.so" }
                    }
                    else if (t.name != "android"  && t.name != "dalvik" ) {
                        from ("$LIBRARY_STUB/${library("glib-lite")}")
                    }
                }
            }


            // javafx.web native libraries

            copy {
                into "${webProject.buildDir}/${moduleNativeDirName}"

                if (IS_COMPILE_WEBKIT) {
                    from ("modules/web/build/libs/${t.name}/${library('jfxwebkit')}")
                } else {
                    if (t.name != "android" && t.name != "ios" && t.name != "dalvik") {
                        from ("$LIBRARY_STUB/${library('jfxwebkit')}")
                    }
                }
            }


            // javafx.packager libraries and executable

            // Copy over the javapackager libs
            copy {
                from "modules/fxpackager/build/libs"
                into "${packagerProject.buildDir}/${platformPrefix}module-lib"
            }

            // Copy over the javapackager executable
            if (t.name == "win" || t.name == "linux" || t.name == "mac") {
                copy {
                    from "modules/fxpackager/build/javapackager"
                    into "${packagerProject.buildDir}/${platformPrefix}module-bin"
                }
            }

        }
    }
    buildModulesTask.dependsOn(buildModuleLibsTask)

    def sdkTask = tasks.getByName("sdk${t.capital}");
    sdkTask.dependsOn(buildModulesTask)
}
sdk.dependsOn(buildModules)

void configureJigsawTests(
        Project p,
        List<String> moduleDeps,
        Set<String> patchInc,
        Set<String> testsInc,
        String addExportsFile
        ) {

    if(!IS_JIGSAW_TEST) {
        return
    }

    p.configurations {
        jigsawTest
    }

    p.dependencies {
        jigsawTest group: "junit", name: "junit", version: "4.8.2"
    }

    compileTargets { t ->

        def targetProperties = project.rootProject.ext[t.upper]

        def modularSdkDirName = "${targetProperties.platformPrefix}modular-sdk"
        def modularSdkDir = "${rootProject.buildDir}/${modularSdkDirName}"
        def modulesDir = "${modularSdkDir}/modules"

        boolean useModule = true
        String moduleName
        if(!p.hasProperty('moduleName')) {
            useModule = false
            moduleName = "systemTests"
        } else {
            moduleName = p.moduleName
        }

        logger.info("configuring $p.name for modular test copy");

        def testingDir = "${rootProject.buildDir}/${targetProperties.platformPrefix}testing";
        def patchesDir = new File("${testingDir}/modules");
        File patchPolicyFile = new File("${testingDir}/java.patch.policy");

        String javaLibraryPath = "${rootProject.buildDir}/sdk/$targetProperties.libDest"

        def jigsawPatchesBaseDir = new File("${testingDir}/modules/$moduleName");
        def jigsawPatchesTestDir = new File("${testingDir}/tests/$moduleName");

        p.files(patchPolicyFile);

        def srcClassesDir = "${p.buildDir}/${targetProperties.platformPrefix}module-classes"
        Task classes =  p.task("jigsawCopyClasses${t.capital}", type: Copy, dependsOn: [p.classes]) {

            enabled = useModule

            from srcClassesDir
            into jigsawPatchesBaseDir
        }

        Task shims =  p.task("jigsawCopyShims${t.capital}", type: Copy, dependsOn: [p.testClasses]) {
            //from p.sourceSets.test.output.classesDir

            enabled = useModule

            from p.sourceSets.test.output
            into jigsawPatchesBaseDir
            if (patchInc != null) {
                include patchInc
            } else {
                include "**/*"
            }
            if (testsInc != null) {
                exclude testsInc
            }
            includeEmptyDirs = false
            doLast() {
                logger.info("project $p.name finished jigsawCopyShims to $jigsawPatchesBaseDir");
            }
        }

        Task alltests =  p.task("jigsawCopyTests${t.capital}", type: Copy, dependsOn: [p.testClasses]) {
            from p.sourceSets.test.output
            into jigsawPatchesTestDir
            if (patchInc != null) {
                exclude patchInc
            }
            if (testsInc != null) {
                include testsInc
            } else {
                include "**/*"
            }
            includeEmptyDirs = false
            doLast() {
                logger.info("project $p.name finished jigsawCopyTests to $jigsawPatchesTestDir");
            }
        }

        // create & use just one of these per platform
        String nameis = "moduleTestPatchPolicy${t.capital}"
        Task patchPerms = null
        if (rootProject.hasProperty(nameis)) {
            patchPerms = rootProject.tasks[nameis]
        } else {
            patchPerms = rootProject.task(nameis) {
                outputs.file(patchPolicyFile)
                doLast() {
                    logger.info("Creating test patch.policy file ${patchPolicyFile}")

                    delete(patchPolicyFile)
                    mkdir(testingDir)

                    [ "base", "graphics", "controls", "fxml", "swing", "web", ].each { mn ->
                        String themod = file("${patchesDir}/javafx.${mn}").toURI()
                        patchPolicyFile <<  "grant codeBase \"${themod}\" {\n" +
                        "    permission java.security.AllPermission;\n" +
                        "};\n"
                    }
                }
            }
        }

        Task jigsawTestsTask =  p.task("jigsawTests${t.capital}", dependsOn: [classes, shims, alltests, patchPerms ]) {
            doLast() {
                logger.info("project $p.name finished jigsawTests${t.capital}");
            }
        }

        FileCollection testclasspath = p.files(p.configurations.jigsawTest)

        p.test.dependsOn jigsawTestsTask

        if (moduleDeps != null) {
            moduleDeps.each() {s->
                logger.info("adding dep to project $p.name $s");
                Project pdep = rootProject.project(s);
                def jigsawTask = pdep.tasks.getByName("jigsawTests${t.capital}");
                jigsawTestsTask.dependsOn jigsawTask;

                testclasspath += p.files(pdep.ext.jigsawPatchesTestDir);
            }
        }

        testclasspath += p.files(jigsawPatchesTestDir);

        p.ext.jigsawTestClasspath = testclasspath
        p.ext.jigsawPatchesTestDir = jigsawPatchesTestDir
        p.ext.jigsawTestClasses = jigsawTestsTask

        p.ext.argclasspathFile = "$testingDir/classpath_"+p.name+".txt"

        p.test {
            if (IS_FORCE_TESTS) {
                dependsOn 'cleanTest'
            }

            scanForTestClasses = false
            include("**/*Test.*")

            if (IS_JIGSAW_TEST) {
                dependsOn jigsawTestsTask

                doFirst {
                    classpath = testclasspath
                    p.sourceSets.test.runtimeClasspath = testclasspath
                }

                String bcp = "-Xbootclasspath/a:" + rootProject.projectDir.path + "/buildSrc/build/libs/buildSrc.jar"

                systemProperties 'worker.debug': false
                systemProperties 'worker.library.path': cygpath(javaLibraryPath)
                systemProperties 'worker.xpatch.dir': cygpath(patchesDir.path)
                if (addExportsFile != null) {
                    systemProperties 'worker.exports.file': cygpath(addExportsFile)
                }
                systemProperties 'worker.classpath.file': cygpath(p.ext.argclasspathFile)
                systemProperties 'worker.java.cmd': JIGSAW_JAVA

                systemProperties 'worker.isJigsaw': true

                systemProperties 'worker.patch.policy': cygpath(patchPolicyFile.path)

                //systemProperties 'prism.order': 'sw'
                //systemProperties 'glass.platform': 'Monocle'
                //systemProperties 'glass.len': 'headless'

                jvmArgs bcp, "workaround.GradleJUnitWorker"

                environment("JDK_HOME", JIGSAW_HOME);
                executable (JIGSAW_JAVA);

              }
        }

    }

}

task checkrepo() {
    doLast {
        logger.info("checking for whitespace (open)");
        exec {
            if (IS_WINDOWS) {
                commandLine  'bash', 'tools/scripts/checkWhiteSpace'
            } else {
                commandLine  'bash', 'tools/scripts/checkWhiteSpace', '-x'
            }
        }
    }
}

task checkrepoall() {
    doLast {
        logger.info("checking for all whitespace (open)");
        exec {
            if (IS_WINDOWS) {
                commandLine  'bash', 'tools/scripts/checkWhiteSpace', '-a'
            } else {
                commandLine  'bash', 'tools/scripts/checkWhiteSpace', '-x', '-a'
            }
        }
    }
}

/******************************************************************************
 *                                                                            *
 *                              BUILD_CLOSED                                  *
 *                                                                            *
 * This next section should remain at the end of the build script. It allows  *
 * for a "supplemental" gradle file to be used to extend the normal build     *
 * structure. For example, this is used for passing a supplemental gradle     *
 * file for producing official JavaFX builds.                                 *
 *                                                                            *
 *****************************************************************************/

if (BUILD_CLOSED) {
    apply from: supplementalBuildFile
}

task showFlags {
}

compileTargets { t ->
    // Every platform must define these variables
    def props = project.ext[t.upper];
    showFlags.dependsOn(
        project.task("showFlags$t.upper") {
            doLast() {
                println "Properties set for $t.upper"
                props.each { println it }
            }
        }
    )

}

